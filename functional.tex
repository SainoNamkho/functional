% -*- coding: utf-8 -*-
% !TEX program = lualatex
\documentclass[oneside]{book}
\usepackage[a4paper,margin=2.5cm]{geometry}

\newcommand*{\myversion}{2022A}
\newcommand*{\mydate}{Version \myversion\ (\the\year-\mylpad\month-\mylpad\day)}
\newcommand*{\mylpad}[1]{\ifnum#1<10 0\the#1\else\the#1\fi}

\setlength{\parindent}{0pt}
\setlength{\parskip}{4pt plus 1pt minus 1pt}

\usepackage{codehigh}

\colorlet{highback}{blue9}
%\CodeHigh{lite}
\CodeHigh{language=latex/latex2,style/main=highback,style/code=highback}
\NewCodeHighEnv{code}{style/main=gray9,style/code=gray9}
\NewCodeHighEnv{demo}{style/main=gray9,style/code=gray9,demo}

\NewDocumentCommand\MySubScript{m}{$_{#1}$}

\ExplSyntaxOn
\NewDocumentCommand\PrintVarList{m}{
  \clist_set:Nn \l_tmpa_clist {#1}
  \clist_map_inline:Nn \l_tmpa_clist
    {
      \token_to_str:N ##1 ~
    }
}
\NewDocumentCommand\RelaceChacters{m}{
  \tl_set:Nn \lTmpaTl {#1}
  \regex_replace_once:nnN { \_ } { \c{MySubScript} } \lTmpaTl
}
\ExplSyntaxOff

\NewDocumentEnvironment{variable}{om}{
  \vspace{5pt}
  \begin{minipage}{\linewidth}
  \hrule\vspace{4pt}\obeylines%
  \begingroup
  \ttfamily\bfseries\color{azure3}
  \PrintVarList{#2}
  \endgroup
  \par\vspace{4pt}\hrule
  \end{minipage}\par\nopagebreak\vspace{4pt}
}{%
  \vspace{5pt}%
}

\NewDocumentEnvironment{function}{om}{
  \vspace{5pt}%
}{\vspace{5pt}}

\NewDocumentEnvironment{syntax}{}{%
  \begin{minipage}{\linewidth}
  \hrule\vspace{4pt}\obeylines%
}{%
  \par\vspace{4pt}\hrule
  \end{minipage}\par\nopagebreak\vspace{4pt}
}

\NewDocumentEnvironment{texnote}{}{}{}

\NewDocumentCommand\cs{m}{%
  \texttt{\bfseries\color{purple3}\expandafter\string\csname#1\endcsname}%
}
\NewDocumentCommand\meta{m}{%
  \RelaceChacters{#1}%
  \textsl{$\langle$\ignorespaces\lTmpaTl\unskip$\rangle$}%
}
\NewDocumentCommand\Arg{m}{%
  \RelaceChacters{#1}%
  \texttt{\{}\textsl{$\langle$\ignorespaces\lTmpaTl\unskip$\rangle$}\texttt{\}}%
}

\NewDocumentCommand\nan{}{\texttt{NaN}}
\NewDocumentCommand\enquote{m}{``#1''}

\let\tn=\cs

\RenewDocumentCommand\emph{m}{%
  \underline{\textsl{#1}}%
}

\usepackage{hyperref}
\hypersetup{
  colorlinks=true,
  urlcolor=blue3,
  linkcolor=blue3,
}

\usepackage{functional}
%\Functional{scoping=false,tracing=true}

\begin{document}

\title{\sffamily LaTeX2 \textcolor{green3}{Functional} Interfaces to LaTeX3 Programming Layer}
\author{Jianrui Lyu (tolvjr@163.com)\\\url{https://github.com/lvjr/functional}}
\date{\mydate\vspace{1cm}\\\myabstract\vspace{10cm}}

\newcommand\myabstract{\parbox{\linewidth}{\hrule\vspace{0.8em}\large
LaTeX3 programming layer (\textsf{expl3}) is very powerful for advanced users,
but it is a little complicated for normal users.
This \textcolor{green3}{\sffamily functional} package aims to provide
intuitive LaTeX2 functional interfaces for it.
\par\vspace{0.5em}
Although there are functions in LaTeX3, the evaluation of them is from outside to inside.
With this package, the evaluation of functions is from inside to outside,
which is the same as other programming languages such as \texttt{JavaScript} or \texttt{Lua}.
In this way, it is rather easy to debug code too.
\par\vspace{0.5em}
Note that many paragraphs in this manual are copied from the documentation of \textsf{expl3}.
\par\vspace{0.8em}\hrule}}

{\let\newpage\relax\vspace{-4cm}\maketitle}

\tableofcontents

\chapter{Overview of Features}

\section{Evaluation from Inside to Outside}

We will compare our first example with a similar \verb!Lua! example:

\begin{code}
-- lua code --
function MathSquare (arg)
  local lTmpaInt = arg * arg
  return lTmpaInt
end
print(MathSquare(5))
print(MathSquare(MathSquare(5)))
\end{code}

\begin{codehigh}
%% function code
\IgnoreSpacesOn
\PrgNewFunction \MathSquare { m } {
  \IntSet \lTmpaInt { \IntEval { #1 * #1 } }
  \Result { \Value \lTmpaInt }
}
\IgnoreSpacesOff
\MathSquare{5}
\MathSquare{\MathSquare{5}}
\end{codehigh}

%\IgnoreSpacesOn
%\PrgNewFunction \MathSquare { m }{
%  \IntSet \lTmpaInt { \IntEval { #1 * #1 } }
%  \Result { \Value \lTmpaInt }
%}
%\IgnoreSpacesOff
%\MathSquare{5}
%\MathSquare{\MathSquare{5}}

%\IgnoreSpacesOn
%\PrgNewFunction \MathCubic { m }
%  {
%    \IntSet \lTmpaInt { \IntEval { #1 * #1 * #1 } }
%    \Result { \Value \lTmpaInt }
%  }
%\IgnoreSpacesOff
%\MathCubic{2}
%\MathCubic{\MathCubic{2}}

Both examples calculate first the square of $5$ and produce $25$,
then calculate the square of $25$ and produce $625$.
In contrast to \verb!expl3!, this \verb!functional! package
does evaluation of functions from inside to outside,
which means composition of functions works like othe programming languages
such as \verb!Lua! or \verb!JavsScript!.

You can define new functions with \cs{PrgNewFunction} command.
To make composition of functions work as expected,
every function \emph{must not} insert directly any token to the input stream.
Instead, a function \emph{must} pass the result (if any) to \verb!functional! package
with \cs{Result} command. And \verb!functional! package is responsible for
inserting result tokens to the input stream at the appropriate time.

To remove space tokens inside function code in defining functions,
you'd better put function definitions inside \verb!\IgnoreSpacesOn! and
\verb!\IgnoreSpacesOff! block. Within this block, \verb!~! is used to input a space.

At the end of this section,
we will compare our factorial example with a similar \verb!Lua! example:

\begin{code}
-- lua code --
function Factorial (n)
  if n == 0 then
    return 1
  else
    return n * Factorial(n-1)
  end
end
print(Factorial(4))
\end{code}

\begin{codehigh}
\IgnoreSpacesOn
\PrgNewFunction \Factorial { m } {
  \IntCompareTF {#1} = {0} {
    \Result {1}
  }{
    \Result { \IntMathMult {#1} { \Factorial { \IntMathSub{#1}{1} } } }
  }
}
\IgnoreSpacesOff
\Factorial{4}
\end{codehigh}

%\IgnoreSpacesOn
%\PrgNewFunction \Factorial { m } {
%  \IntCompareTF {#1} = {0} {
%    \Result {1}
%  }{
%    \Result { \IntMathMult {#1} { \Factorial { \IntMathSub{#1}{1} } } }
%  }
%}
%\IgnoreSpacesOff
%\Factorial{0}
%\Factorial{4}

\section{Group Scoping of Functions}

In \verb!Lua! language, a function or a condition expression makes a block,
and the values of local variables will be reset after a block.
For example

\begin{code}
-- lua code --
local a = 1
print(a)          ---- 1
function SomeFun()
  local a = 2
  print(a)        ---- 2
  if 1 > 0 then
    local a = 3
    print(a)      ---- 3
  end
  print(a)        ---- 2
end
SomeFun()
print(a)          ---- 1
\end{code}

In \verb!functional! package, a condition expression is in fact a function,
and you can make every function become a group by setting
\verb!\Functional{scoping=true}!. For example

\begin{codehigh}
\Functional{scoping=true}
\IgnoreSpacesOn
\IntSet \lTmpaInt {1}
\IntLogVar \lTmpaInt          % ---- 1
\PrgNewFunction \SomeFun { } {
  \IntSet \lTmpaInt {2}
  \IntLogVar \lTmpaInt        % ---- 2
  \IntCompareTF {1} > {0} {
    \IntSet \lTmpaInt {3}
    \IntLogVar \lTmpaInt      % ---- 3
  }{ }
  \IntLogVar \lTmpaInt        % ---- 2
}
\SomeFun
\IntLogVar \lTmpaInt          % ---- 1
\IgnoreSpacesOff
\end{codehigh}

Same as \verb!expl3!, the names of local variables \emph{must} start with \verb!l!,
while names of global variables \emph{must} start with \verb!g!.
The difference is that \verb!functional! package provides only one function for setting
both local and global varianbles of the same type,
by checking leading letters of their names. So for integer variables, you can write
\verb!\IntSet\lTmpaInt{1}! and \verb!\IntSet\gTmpbInt{2}!.

The previous example will produce different result
if we change variable from \verb!\lTmpaInt! to \verb!\gTmpaInt!.

\begin{codehigh}
\Functional{scoping=true}
\IgnoreSpacesOn
\IntSet \gTmpaInt {1}
\IntLogVar \gTmpaInt          % ---- 1
\PrgNewFunction \SomeFun { } {
  \IntSet \gTmpaInt {2}
  \IntLogVar \gTmpaInt        % ---- 2
  \IntCompareTF {1} > {0} {
    \IntSet \gTmpaInt {3}
    \IntLogVar \gTmpaInt      % ---- 3
  }{ }
  \IntLogVar \gTmpaInt        % ---- 3
}
\SomeFun
\IntLogVar \gTmpaInt          % ---- 3
\IgnoreSpacesOff
\end{codehigh}

As you can see, the values of global variables will never be reset after a group.

\section{Tracing Evaluation of Functions}

Since every function in \verb!functional! package will pass its return value to
the package, it is quite easy to debug your code.
You can turn on the tracing by setting \verb!\Functional{tracing=true}!.
For example, the tracing log of the first example in this chapter will be the following:

% FIXME: spaces at the first line will be removed
%\begin{codehigh}[]
%    [I] \MathSquare{5}
%            [I] \IntEval{5*5}
%                    [I] \Expand{\int_eval:n {5*5}}
%                    [O] 25
%                [I] \Result{25}
%                [O] 25
%            [O] 25
%        [I] \IntSet\lTmpaInt {25}
%        [O]
%            [I] \Value\lTmpaInt
%            [O] 25
%        [I] \Result{25}
%        [O] 25
%    [O] 25
%\end{codehigh}
\begin{codehigh}[]
[I] \MathSquare{5}
        [I] \IntEval{5*5}
                [I] \Expand{\int_eval:n {5*5}}
                [O] 25
            [I] \Result{25}
            [O] 25
        [O] 25
    [I] \IntSet\lTmpaInt {25}
    [O]
        [I] \Value\lTmpaInt
        [O] 25
    [I] \Result{25}
    [O] 25
[O] 25
[I] \MathSquare{25}
        [I] \IntEval{25*25}
                [I] \Expand{\int_eval:n {25*25}}
                [O] 625
            [I] \Result{625}
            [O] 625
        [O] 625
    [I] \IntSet\lTmpaInt {625}
    [O]
        [I] \Value\lTmpaInt
        [O] 625
    [I] \Result{625}
    [O] 625
[O] 625
\end{codehigh}

\section{Definitions of Functions}

Within \verb!expl3!, there are eight commands for defining new functions,
which is good for power users.

\begin{code}[language=latex/latex3]
\cs_new:Npn
\cs_new_nopar:Npn
\cs_new_protected:Npn
\cs_new_protected_nopar:Npn
\cs_new:Nn
\cs_new_nopar:Nn
\cs_new_protected:Nn
\cs_new_protected_nopar:Nn
\end{code}

Within \verb!functional! package, there is only one command (\cs{PrgNewFunction})
for defining new functions, which is good for normal users.
The created functions are always protected and accept \verb!\par! in their arguments.

Since \verb!functional! package gets the results of functions by evaluation
(including expansion and execution by \TeX), it is natural to protect all functions.

\section{Variants of Arguments}

Within \verb!expl3!, there are several expansion variants for arguments,
and many expansion functions for expanding them, which are necessary for power users.

\begin{code}[language=latex/latex3]
\module_foo:c
\module_bar:e
\module_bar:x
\module_bar:f
\module_bar:o
\module_bar:V
\module_bar:v
\end{code}

\begin{code}[language=latex/latex3]
\exp_args:Nc
\exp_args:Ne
\exp_args:Nx
\exp_args:Nf
\exp_args:No
\exp_args:NV
\exp_args:Nv
\end{code}

Within \verb!functional! package, there are only three variants
(\verb!c!, \verb!e!, \verb!V!) are provided, and these variants are defined
as functions (\cs{Name}, \cs{Expand}, \cs{Value}, respetively),
which are easier to use for normal users.

\begin{demohigh}
\newcommand\test{uvw}
\Name{test}
\end{demohigh}

\begin{demohigh}
\newcommand\test{uvw}
\Expand{111\test222}
\end{demohigh}

\begin{demohigh}
\IntSet\lTmpaInt{123}
\Value\lTmpaInt
\end{demohigh}

The most interesting feature is that you can compose these functions.
For example, you can easily get the \verb!v! variant of \verb!expl3! by
simply composing \cs{Name} and \cs{Value} functions:

\begin{demohigh}
\IntSet\lTmpaInt{123}
\Value{\Name{lTmpaInt}}
\end{demohigh}

\chapter{Functional Progarmming (\texttt{Prg})}

\section{Deﬁning Functions and Conditionals}

\begin{function}{\PrgNewFunction}
\begin{syntax}
\cs{PrgNewFunction} \meta{function} \Arg{argument specification} \Arg{code}
\end{syntax}
Creates protected \meta{function} for evaluating the \meta{code}.
Within the \meta{code}, the parameters (\verb|#1|, \verb|#2|,
\emph{etc.}) will be replaced by those absorbed by the function.
The returned value \emph{must} be passed with \cs{Result} function.
The definition is global and an error results if the
\meta{function} is already defined.\par
The \Arg{argument specification} in a list of letters,
where each letter is one of the following argument specifiers
(nearly all of them are \texttt{M} or \texttt{m} for functions provided by this package):\par
{\centering\begin{tabular}{ll}
%\hline
  \texttt{M} & single-token argument, which will be manipulated first \\
  \texttt{m} & multi-token argument, which will be manipulated first \\
  \texttt{N} & single-token argument, which will not be manipulated first \\
  \texttt{n} & multi-token argument, which will not be manipulated first \\
%\hline
\end{tabular}\par}
The argument manipulation for argument type \texttt{M} or \texttt{m}
is: if the argument starts with a function defined with \cs{PrgNewFunction},
the argument will be evaluated and replaced with the returned value.
\end{function}

\begin{function}{\PrgNewConditional}
\begin{syntax}
\cs{PrgNewConditional} \meta{function} \Arg{argument specification} \Arg{code}
\end{syntax}
Creates protected conditional \meta{function} for evaluating the \meta{code}.
The returned value of the \meta{function} \emph{must} be either \verb!\cTrueBool!
or \verb!\cFalseBool! and be passed with \cs{Result} function..
The definition is global and an error results if the \meta{function} is already defined.
\par
Assume the \meta{function} is \verb!\FooIfBar!, then another function \verb!\FooIfBarTF!
will be created at the same time. \verb!\FooIfBarTF! function has two extra arguments
which are \Arg{true code} and \Arg{false code}.\par
\end{function}

\section{Collecting Returned Values}

\begin{function}{\Result}
\begin{syntax}
\cs{Result} \Arg{tokens}
\end{syntax}
Appends \meta{tokens} to \verb!\gResultTl!, which holds the returned value of current function.
This function is normally used in the \meta{code} of \cs{PrgNewFunction} and \cs{PrgNewConditional}.
\end{function}

\chapter{Argument Using (\texttt{Use})}

\section{Expanding Tokens}

\begin{function}{\Name}
\begin{syntax}
\cs{Name} \Arg{control sequence name}
\end{syntax}
Expands the \meta{control sequence name} until only characters
remain, then converts this into a control sequence and returns it.
The \meta{control sequence name} must consist of character tokens %,
%typically a mixture of category code $10$ (space), $11$ (letter) and $12$ (other).
when exhaustively expanded.%
%\begin{texnote}
%Protected macros that appear in a \texttt{c}-type argument are
%expanded despite being protected; \cs{exp_not:n} also has no
%effect.  An internal error occurs if non-characters or active
%characters remain after full expansion, as the conversion to a
%control sequence is not possible.
%\end{texnote}
\end{function}

\begin{function}{\Value}
\begin{syntax}
\cs{Value} \meta{variable}
\end{syntax}
Recovers the content of a \meta{variable} and returns the value.
An error is raised if the variable does not exist or if it is invalid.
Note that it is the same as \cs{TlUse} for \meta{tl var}, or \cs{IntUse} for \meta{int var}.
\end{function}

\begin{function}{\Expand}
\begin{syntax}
\cs{Expand} \Arg{tokens}
\end{syntax}
Expands the \meta{tokens} exhaustively and returns the result.
\end{function}

\begin{function}{\ExpNot}
\begin{syntax}
\cs{ExpNot} \Arg{tokens}
\end{syntax}
Prevents expansion of the \meta{tokens} inside the argument of \cs{Expand} function.
The argument of \cs{ExpNot} \emph{must} be surrounded by braces.
%\begin{texnote}
%This is the \eTeX{} \tn{unexpanded} primitive.  In an
%|x|-expanding definition (\cs{cs_new:Npx}), \cs{exp_not:n}~|{#1}|
%is equivalent to |##1| rather than to~|#1|, namely it inserts the
%two characters |#| and~|1|.  In an |e|-type argument
%\cs{exp_not:n}~|{#}| is equivalent to |#|, namely it inserts the
%character~|#|.
%\end{texnote}
\end{function}

\begin{function}{\ExpValue}
\begin{syntax}
\cs{ExpValue} \meta{variable}
\end{syntax}
Recovers the content of the \meta{variable}, then prevents expansion
of this material inside the argument of \cs{Expand} function.
\end{function}

\section{Using Tokens}

\begin{function}{\UseOne,\GobbleOne}
\begin{syntax}
\cs{UseOne} \Arg{argument}
\cs{GobbleOne} \Arg{argument}
\end{syntax}
The function \cs{UseOne} absorbs one argument and returns it.
%\begin{texnote}
%The \cs{UseOne} function is equivalent to \LaTeXe{}'s \tn{@firstofone}.
%\end{texnote}
\cs{GobbleOne} absorbs one argument and returns nothing.
%\begin{texnote}
%These are equivalent to \LaTeXe{}'s \tn{@gobble}, \tn{@gobbbletwo},
%\emph{etc.}
%\end{texnote}
For example
\begin{demohigh}
\UseOne{abc}\GobbleOne{ijk}\UseOne{xyz}
\end{demohigh}
\end{function}

\begin{function}{\UseGobble,\GobbleUse}
\begin{syntax}
\cs{UseGobble} \Arg{arg_1} \Arg{arg_2}
\cs{GobbleUse} \Arg{arg_1} \Arg{arg_2}
\end{syntax}
These functions absorb two arguments.
The function \cs{UseGobble} discards the second argument,
and returns the content of the first argument.
\cs{GobbleUse} discards the first argument,
and returns the content of the second argument.
%\begin{texnote}
%These are equivalent to \LaTeXe{}'s \tn{@firstoftwo} and
%\tn{@secondoftwo}.
%\end{texnote}
For example
\begin{demohigh}
\UseGobble{abc}{uvw}\GobbleUse{abc}{uvw}
\end{demohigh}
\end{function}

\chapter{Control Structures (\texttt{Bool})}

\section{Constant and Scratch Booleans}

\begin{variable}{\cTrueBool,\cFalseBool}
Constants that represent \verb|true| and \verb|false|, respectively. Used to
implement predicates. For example
\begin{demohigh}
\BoolVarIfTF\cTrueBool{\Result{True!}}{\Result{False!}}
\BoolVarIfTF\cFalseBool{\Result{True!}}{\Result{False!}}
\end{demohigh}
\end{variable}

\begin{variable}{\lTmpaBool,\lTmpbBool,\lTmpcBool,\lTmpiBool,\lTmpjBool,\lTmpkBool}
Scratch booleans for local assignment. These are never used by
the \verb!functional! package, and so are safe for use with any
function. However, they may be overwritten by other
code and so should only be used for short-term storage.
\end{variable}

\begin{variable}{\gTmpaBool,\gTmpbBool,\gTmpcBool,\gTmpiBool,\gTmpjBool,\gTmpkBool}
Scratch booleans for global assignment. These are never used by
the \verb!functional! package, and so are safe for use with any
function. However, they may be overwritten by other
code and so should only be used for short-term storage.
\end{variable}

\section{Creating and Setting Booleans}

\begin{function}{\BoolNew}
\begin{syntax}
\cs{BoolNew} \meta{boolean}
\end{syntax}
Creates a new \meta{boolean} or raises an error if the
name is already taken. The declaration is global. The
\meta{boolean} is initially \texttt{false}.
\end{function}

\begin{function}{\BoolConst}
\begin{syntax}
\cs{BoolConst} \meta{boolean} \Arg{boolexpr}
\end{syntax}
Creates a new constant \meta{boolean} or raises an error if the name
is already taken. The value of the \meta{boolean} is set globally to
the result of evaluating the \meta{boolexpr}.
For example
\begin{codehigh}
\BoolConst \cFooSomeBool {\IntCompare{3}>{2}}
\BoolVarLog \cFooSomeBool
\end{codehigh}
\end{function}

\begin{function}{\BoolSet}
\begin{syntax}
\cs{BoolSet} \meta{boolean} \Arg{boolexpr}
\end{syntax}
Evaluates the \meta{boolean expression} and sets the \meta{boolean} variable to
the logical truth of this evaluation.
For example
\begin{codehigh}
\BoolSet \lTmpaBool {\IntCompare{3}<{2}}
\BoolVarLog \lTmpaBool
\end{codehigh}
\end{function}

\begin{function}{\BoolSetTrue}
\begin{syntax}
\cs{BoolSetTrue} \meta{boolean}
\end{syntax}
Sets \meta{boolean} logically \texttt{true}.
\end{function}

\begin{function}{\BoolSetFalse}
\begin{syntax}
\cs{BoolSetFalse} \meta{boolean}
\end{syntax}
Sets \meta{boolean} logically \texttt{false}.
\end{function}

\begin{function}{\BoolSetEq}
\begin{syntax}
\cs{BoolSetEq} \meta{boolean_1} \meta{boolean_2}
\end{syntax}
Sets \meta{boolean_1} to the current value of \meta{boolean_2}.
For example
\begin{codehigh}
\BoolSetTrue \lTmpaBool
\BoolSetEq \lTmpbBool \lTmpaBool
\BoolVarLog \lTmpbBool
\end{codehigh}
\end{function}

\section{Viewing Booleans}

\begin{function}{\BoolLog}
\begin{syntax}
\cs{BoolLog} \Arg{boolean expression}
\end{syntax}
Writes the logical truth of the \meta{boolean expression} in the log file.
\end{function}

\begin{function}{\BoolVarLog}
\begin{syntax}
\cs{BoolVarLog} \meta{boolean}
\end{syntax}
Writes the logical truth of the \meta{boolean} in the log file.
\end{function}

\begin{function}{\BoolShow}
\begin{syntax}
\cs{BoolShow} \Arg{boolean expression}
\end{syntax}
Displays the logical truth of the \meta{boolean expression} on the terminal.
\end{function}

\begin{function}{\BoolVarShow}
\begin{syntax}
\cs{BoolVarShow} \meta{boolean}
\end{syntax}
Displays the logical truth of the \meta{boolean} on the terminal.
\end{function}

\section{Booleans and Conditionals}

\begin{function}{\BoolIfExist,\BoolIfExistTF}
\begin{syntax}
\cs{BoolIfExist} \meta{boolean}
\cs{BoolIfExistTF} \meta{boolean} \Arg{true code} \Arg{false code}
\end{syntax}
Tests whether the \meta{boolean} is currently defined.  This does not
check that the \meta{boolean} really is a boolean variable.
For example
\begin{demohigh}
\BoolIfExistTF \lTmpaBool {\Result{Yes}} {\Result{No}}
\BoolIfExistTF \lFooUndefinedBool {\Result{Yes}} {\Result{No}}
\end{demohigh}
\end{function}

\begin{function}{\BoolVarIf,\BoolVarIfTF}
\begin{syntax}
\cs{BoolVarIf} \meta{boolean}
\cs{BoolVarIfTF} \meta{boolean} \Arg{true code} \Arg{false code}
\end{syntax}
Tests the current truth of \meta{boolean}, and continues evaluation
based on this result. For example
\begin{demohigh}
\BoolSetTrue \lTmpaBool
\BoolVarIfTF \lTmpaBool {\Result{True!}} {\Result{False!}}
\BoolSetFalse \lTmpaBool
\BoolVarIfTF \lTmpaBool {\Result{True!}} {\Result{False!}}
\end{demohigh}
\end{function}

\begin{function}{\BoolVarNot,\BoolVarNotTF}
\begin{syntax}
\cs{BoolVarNot} \meta{boolean}
\cs{BoolVarNotTF} \meta{boolean} \Arg{true code} \Arg{false code}
\end{syntax}
Evaluates \meta{true code} if \meta{boolean} is \verb!false!,
and \meta{false code} If \meta{boolean} is \verb!true!.
For example
\begin{demohigh}
\BoolVarNotTF {\IntCompare{3}>{2}} {\Result{Yes}} {\Result{No}}
\end{demohigh}
\end{function}

\begin{function}{\BoolVarAnd,\BoolVarAndTF}
\begin{syntax}
\cs{BoolVarAnd} \meta{boolean_1} \meta{boolean_2}
\cs{BoolVarAndTF} \meta{boolean_1} \meta{boolean_2} \Arg{true code} \Arg{false code}
\end{syntax}
Implements the \enquote{And} operation between two booleans,
hence is \texttt{true} if both are \texttt{true}.
%Contrarily to the infix operator \verb|&&|,
The \meta{boolean_2} is only evaluated if it is needed to determine the result of
\cs{BoolVarAnd}.
For example
\begin{demohigh}
\BoolVarAndTF {\IntCompare{3}>{2}} {\IntCompare{3}>{4}} {\Result{Yes}} {\Result{No}}
\end{demohigh}
\end{function}

\begin{function}{\BoolVarOr,\BoolVarOrTF}
\begin{syntax}
\cs{BoolVarOr} \meta{boolean_1} \meta{boolean_2}
\cs{BoolVarOrTF} \meta{boolean_1} \meta{boolean_2} \Arg{true code} \Arg{false code}
\end{syntax}
Implements the \enquote{Or} operation between two booleans,
hence is \texttt{true} if either one is \texttt{true}.
%Contrarily to the infix operator \verb"||",
The \meta{boolean_2} is only evaluated if it is needed to determine the result of
\cs{BoolVarOr}.
For example
\begin{demohigh}
\BoolVarOrTF {\IntCompare{3}>{2}} {\IntCompare{3}>{4}} {\Result{Yes}} {\Result{No}}
\end{demohigh}
\end{function}

\begin{function}{\BoolVarXor,\BoolVarXorTF}
\begin{syntax}
\cs{BoolVarXor} \meta{boolean_1} \meta{boolean_2}
\cs{BoolVarXorTF} \meta{boolean_1} \meta{boolean_2} \Arg{true code} \Arg{false code}
\end{syntax}
Implements an \enquote{exclusive or} operation between two booleans.
For example
\begin{demohigh}
\BoolVarXorTF {\IntCompare{3}>{2}} {\IntCompare{3}>{4}} {\Result{Yes}} {\Result{No}}
\end{demohigh}
\end{function}

\chapter{Token Lists (\texttt{Tl})}

\section{Constant and Scratch Token Lists}

\begin{variable}{\cSpaceTl}
An explicit space character contained in a token list%
%(compare this with \cs{c_space_token})
. For use where an explicit space is required.
\end{variable}

\begin{variable}{\cEmptyTl}
Constant that is always empty.
\end{variable}

%\begin{variable}{\cNoValueTl}
%A marker for the absence of an argument. This constant \verb|tl| can safely
%be typeset (\emph{cf.}~\cs{qNil}), with the result being \verb|-NoValue-|.
%It is important to note that \cs{cNoValueTl} is constructed such that it
%will \emph{not} match the simple text input \verb|-NoValue-|, \emph{i.e.}
%that
%\begin{demohigh}
%\TlIfEqTF {\TlUse\cNoValueTl} {-NoValue-} {Result{Yes}} {\Result{No}}
%\end{demohigh}
%The \cs{cNoValueTl} marker is intended for
%use in creating document-level interfaces, where it serves as an indicator
%that an (optional) argument was omitted. In particular, it is distinct
%from a simple empty \verb|tl|.
%\end{variable}

\begin{variable}{\lTmpaTl,\lTmpbTl,\lTmpcTl,\lTmpiTl,\lTmpjTl,\lTmpkTl}
Scratch token lists for local assignment. These are never used by
the \verb!functional! package, and so are safe for use with any
function. However, they may be overwritten by other
code and so should only be used for short-term storage.
\end{variable}

\begin{variable}{\gTmpaTl,\gTmpbTl,\gTmpcTl,\gTmpiTl,\gTmpjTl,\gTmpkTl}
Scratch token lists for global assignment. These are never used by
the \verb!functional! package, and so are safe for use with any
function. However, they may be overwritten by other
code and so should only be used for short-term storage.
\end{variable}

\section{Creating and Using Token Lists}

\begin{function}{\TlNew}
\begin{syntax}
\cs{TlNew} \meta{tl var}
\end{syntax}
Creates a new \meta{tl var} or raises an error if the
name is already taken. The declaration is global. The
\meta{tl~var} is initially empty.
\end{function}

\begin{function}{\TlConst}
\begin{syntax}
\cs{TlConst} \meta{tl var} \Arg{token list}
\end{syntax}
Creates a new constant \meta{tl var} or raises an error
if the name is already taken. The value of the
\meta{tl var} is set globally to the \meta{token list}.
\end{function}

\begin{function}{\TlUse}
\begin{syntax}
\cs{TlUse} \meta{tl~var}
\end{syntax}
Recovers the content of a \meta{tl~var} and returns the value.
An error is raised if the variable
does not exist or if it is invalid. Note that it is possible to use
a \meta{tl~var} directly without an accessor function.
\end{function}

\begin{function}{\TlToStr}
\begin{syntax}
\cs{TlToStr} \Arg{token list}
\end{syntax}
Converts the \meta{token list} to a \meta{string}, returning the
resulting character tokens. A \meta{string}
is a series of tokens with category code $12$ (other) with the exception
of spaces, which retain category code $10$ (space).
%This function requires only a single expansion.
%Its argument \emph{must} be braced.
%\begin{texnote}
%This is the \eTeX{} primitive \tn{detokenize}.
%Converting a \meta{token list} to a \meta{string} yields a
%concatenation of the string representations of every token in the
%\meta{token list}.
%The string representation of a control sequence is
%\begin{itemize}
%\item an escape character, whose character code is given by the
%internal parameter \tn{escapechar}, absent if the
%\tn{escapechar} is negative or greater than the largest
%character code;
%\item the control sequence name, as defined by \cs{cs_to_str:N};
%\item a space, unless the control sequence name is a single
%character whose category at the time of expansion of
%\cs{tl_to_str:n} is not \enquote{letter}.
%\end{itemize}
%The string representation of an explicit character token is that
%character, doubled in the case of (explicit) macro parameter
%characters (normally \verb|#|).
%In particular, the string representation of a token list may
%depend on the category codes in effect when it is evaluated, and
%the value of the \tn{escapechar}: for instance |\tl_to_str:n {\a}|
%normally produces the three character \enquote{backslash},
%\enquote{lower-case a}, \enquote{space}, but it may also produce a
%single \enquote{lower-case a} if the escape character is negative
%and \texttt{a} is currently not a letter.
%\end{texnote}
\end{function}

\begin{function}{\TlVarToStr}
\begin{syntax}
\cs{TlVarToStr} \meta{tl var}
\end{syntax}
Converts the content of the \meta{tl var} to a string, returning the
resulting character tokens. A \meta{string}
is a series of tokens with category code $12$ (other) with the exception
of spaces, which retain category code $10$ (space).
\end{function}

\section{Viewing Token Lists}

\begin{function}{\TlLog}
\begin{syntax}
\cs{TlLog} \Arg{token list}
\end{syntax}
Writes the \meta{token list} in the log file. See also
\cs{TlShow} which displays the result in the terminal.
\end{function}

\begin{function}{\TlVarLog}
\begin{syntax}
\cs{TlVarLog} \meta{tl var}
\end{syntax}
Writes the content of the \meta{tl var} in the log file. See also
\cs{TlVarShow} which displays the result in the terminal.
\end{function}

\begin{function}{\TlShow}
\begin{syntax}
\cs{TlShow} \Arg{token list}
\end{syntax}
Displays the \meta{token list} on the terminal.
%\begin{texnote}
%This is similar to the \eTeX{} primitive \tn{showtokens}, wrapped
%to a fixed number of characters per line.
%\end{texnote}
\end{function}

\begin{function}{\TlVarShow}
\begin{syntax}
\cs{TlVarShow} \meta{tl var}
\end{syntax}
Displays the content of the \meta{tl var} on the terminal.
\begin{texnote}
This is similar to the \TeX{} primitive \tn{show}, wrapped to a
fixed number of characters per line.
\end{texnote}
\end{function}

\section{Setting Token List Variables}

\begin{function}{\TlSet}
\begin{syntax}
\cs{TlSet} \meta{tl~var} \Arg{tokens}
\end{syntax}
Sets \meta{tl~var} to contain \meta{tokens},
removing any previous content from the variable. For example
\begin{demohigh}
\TlSet \lTmpiTl {\IntMathMult{4}{5}}
\TlUse \lTmpiTl
\end{demohigh}
\end{function}

\begin{function}{\TlClear}
\begin{syntax}
\cs{TlClear} \meta{tl~var}
\end{syntax}
Clears all entries from the \meta{tl~var}. For example
\begin{demohigh}
\TlSet \lTmpjTl {One}
\TlClear \lTmpjTl
\TlSet \lTmpjTl {Two}
\TlUse \lTmpjTl
\end{demohigh}
\end{function}

\begin{function}{\TlClearNew}
\begin{syntax}
\cs{TlClearNew} \meta{tl var}
\end{syntax}
Ensures that the \meta{tl var} exists globally by applying
\cs{TlNew} if necessary, then applies \cs{TlClear} to leave
the \meta{tl var} empty.
\end{function}

\begin{function}{\TlSetEq}
\begin{syntax}
\cs{TlSetEq} \meta{tl var_1} \meta{tl var_2}
\end{syntax}
Sets the content of \meta{tl var_1} equal to that of
\meta{tl var_2}.
\end{function}

\begin{function}{\TlConcat}
\begin{syntax}
\cs{TlConcat} \meta{tl var_1} \meta{tl var_2} \meta{tl var_3}
\end{syntax}
Concatenates the content of \meta{tl var_2} and \meta{tl var_3}
together and saves the result in \meta{tl var_1}. The \meta{tl var_2}
is placed at the left side of the new token list.
\end{function}

\begin{function}{\TlPutLeft}
\begin{syntax}
\cs{TlPutLeft} \meta{tl~var} \Arg{tokens}
\end{syntax}
Appends \meta{tokens} to the left side of the current content of
\meta{tl~var}. For example
\begin{demohigh}
\TlSet \lTmpkTl {Functional}
\TlPutLeft \lTmpkTl {Hello}
\TlUse \lTmpkTl
\end{demohigh}
\end{function}

\begin{function}{\TlPutRight}
\begin{syntax}
\cs{TlPutRight} \meta{tl~var} \Arg{tokens}
\end{syntax}
Appends \meta{tokens} to the right side of the current content of
\meta{tl~var}. For example
\begin{demohigh}
\TlSet \lTmpkTl {Functional}
\TlPutRight \lTmpkTl {World}
\TlUse \lTmpkTl
\end{demohigh}
\end{function}

\section{Replacing Tokens}

Within token lists, replacement takes place at the top level: there is
no recursion into brace groups (more precisely, within a group defined by
a categroy code $1$/$2$ pair).

\begin{function}{\TlReplaceOnce}
\begin{syntax}
\cs{TlReplaceOnce} \meta{tl var} \Arg{old tokens} \Arg{new tokens}
\end{syntax}
Replaces the first (leftmost) occurrence of \meta{old tokens} in the
\meta{tl var} with \meta{new tokens}. \meta{Old tokens}
cannot contain \verb|{|, \verb|}| or \verb|#|
(more precisely, explicit character tokens with category code $1$
(begin-group) or $2$ (end-group), and tokens with category code $6$).
\end{function}

\begin{function}{\TlReplaceAll}
\begin{syntax}
\cs{TlReplaceAll} \meta{tl var} \Arg{old tokens} \Arg{new tokens}
\end{syntax}
Replaces all occurrences of \meta{old tokens} in the
\meta{tl var} with \meta{new tokens}. \meta{Old tokens}
cannot contain \verb|{|, \verb|}| or \verb|#|
(more precisely, explicit character tokens with category code $1$
(begin-group) or $2$ (end-group), and tokens with category code $6$).
As this function
operates from left to right, the pattern \meta{old tokens}
may remain after the replacement (see \cs{TlRemoveAll}
for an example).
\end{function}

\begin{function}{\TlRemoveOnce}
\begin{syntax}
\cs{TlRemoveOnce} \meta{tl var} \Arg{tokens}
\end{syntax}
Removes the first (leftmost) occurrence of \meta{tokens} from the
\meta{tl var}. \meta{Tokens} cannot contain \verb|{|, \verb|}| or \verb|#|
(more precisely, explicit character tokens with category code $1$
(begin-group) or $2$ (end-group), and tokens with category code $6$).
\end{function}

\begin{function}{\TlRemoveAll}
\begin{syntax}
\cs{TlRemoveAll} \meta{tl var} \Arg{tokens}
\end{syntax}
Removes all occurrences of \meta{tokens} from the
\meta{tl var}. \meta{Tokens} cannot contain \verb|{|, \verb|}| or \verb|#|
(more precisely, explicit character tokens with category code $1$
(begin-group) or $2$ (end-group), and tokens with category code $6$).
As this function
operates from left to right, the pattern \meta{tokens}
may remain after the removal, for instance,
\begin{demohigh}
\TlSet \lTmpaTl {abbccd}
\TlRemoveAll \lTmpaTl {bc}
\TlUse \lTmpaTl
\end{demohigh}
\end{function}

\begin{function}{\TlTrimSpaces}
\begin{syntax}
\cs{TlTrimSpaces} \Arg{token list}
\end{syntax}
Removes any leading and trailing explicit space characters
(explicit tokens with character code $32$ and category code $10$)
from the \meta{token list} and returns the result.
%\begin{texnote}
%The result is returned within \tn{unexpanded}, which means that the token
%list does not expand further when appearing in an \texttt{x}-type
%or \texttt{e}-type argument expansion.
%\end{texnote}
\end{function}

\begin{function}{\TlVarTrimSpaces}
\begin{syntax}
\cs{TlVarTrimSpaces} \meta{tl var}
\end{syntax}
Sets the \meta{tl var} to contain the result of removing any leading
and trailing explicit space characters (explicit tokens with
character code $32$ and category code $10$) from its contents.
\end{function}

\section{Working with the Content of Token Lists}

\begin{function}{\TlCount}
\begin{syntax}
\cs{TlCount} \Arg{tokens}
\end{syntax}
Counts the number of \meta{items} in \meta{tokens} and returns this information.
Unbraced tokens count as one element as do each token group (\verb|{|$\cdots$\verb|}|).
This process ignores any unprotected spaces within \meta{tokens}. %See also \cs{TlVarCount}.
%This function requires three expansions, giving an \meta{integer denotation}.
\end{function}

\begin{function}{\TlVarCount}
\begin{syntax}
\cs{TlVarCount} \meta{tl var}
\end{syntax}
Counts the number of \meta{items} in the \meta{tl var} and returns this information.
Unbraced tokens count as one element as do each token group (\verb|{|$\cdots$\verb|}|).
This process ignores any unprotected spaces within the \meta{tl var}. %See also \cs{TlCount}.
%This function requires three expansions, giving an \meta{integer denotation}.
\end{function}

\begin{function}{\TlHead}
\begin{syntax}
\cs{TlHead} \Arg{token list}
\end{syntax}
Returns the first \meta{item} in the \meta{token list},
discarding the rest of the \meta{token list}.
All leading explicit space characters
(explicit tokens with character code $32$ and category code $10$)
are discarded; for example
\begin{demohigh}
\fbox {1\TlHead{ abc }2}
\fbox {1\TlHead{  abc }2}
\end{demohigh}
If the \enquote{head} is a brace group, rather than a single token,
the braces are removed, and so
\begin{codehigh}
\TlHead { { ab} c }
\end{codehigh}
yields \verb*| ab|.
A blank \meta{token list} (see \cs{TlIfBlank}) results in
\cs{TlHead} returning nothing.
%\begin{texnote}
%The result is returned within \cs{exp_not:n}, which means that the token
%list does not expand further when appearing in an \texttt{x}-type
%or \texttt{e}-type argument expansion.
%\end{texnote}
\end{function}

\begin{function}{\TlVarHead}
\begin{syntax}
\cs{TlVarHead} \meta{tl var}
\end{syntax}
Returns the first \meta{item} in the \meta{tl var},
discarding the rest of the \meta{tl var}.
All leading explicit space characters
(explicit tokens with character code $32$ and category code $10$)
are discarded.
\end{function}

\begin{function}{\TlTail}
\begin{syntax}
\cs{TlTail} \Arg{token list}
\end{syntax}
Discards all leading explicit space characters
(explicit tokens with character code $32$ and category code $10$)
and the first \meta{item} in the \meta{token list}, and returns the
remaining tokens. Thus for example
\begin{codehigh}
\TlTail { a {bc} d }
\end{codehigh}
and
\begin{codehigh}
\TlTail {  a {bc} d }
\end{codehigh}
both return \verb*| {bc} d |.  A blank \meta{token list} (see \cs{TlIfBlank})
results in \cs{TlTail} returning nothing.
%\begin{texnote}
%The result is returned within \cs{exp_not:n}, which means that the
%token list does not expand further when appearing in an \texttt{x}-type
%or \texttt{e}-type argument expansion.
%\end{texnote}
\end{function}

\begin{function}{\TlVarTail}
\begin{syntax}
\cs{TlVarTail} \meta{tl var}
\end{syntax}
Discards all leading explicit space characters
(explicit tokens with character code $32$ and category code $10$)
and the first \meta{item} in the \meta{tl var}, and returns the
remaining tokens.
\end{function}

\begin{function}{\TlItem,\TlVarItem}
\begin{syntax}
\cs{TlItem} \Arg{token list} \Arg{integer expression}
\cs{TlVarItem} \meta{tl var} \Arg{integer expression}
\end{syntax}
Indexing items in the \meta{token list} from $1$ on the left, this
function evaluates the \meta{integer expression} and returns the
appropriate item from the \meta{token list}.
If the \meta{integer expression} is negative, indexing occurs from
the right of the token list, starting at $-1$ for the right-most item.
If the index is out of bounds, then the function returns nothing.
%\begin{texnote}
%The result is returned within the \tn{unexpanded}
%primitive (\cs{exp_not:n}), which means that the \meta{item}
%does not expand further when appearing in an \texttt{x}-type
%or \texttt{e}-type argument expansion.
%\end{texnote}
\end{function}

\begin{function}{\TlRandItem,\TlVarRandItem}
\begin{syntax}
\cs{TlRandItem} \Arg{token list}
\cs{TlVarRandItem} \meta{tl var}
\end{syntax}
Selects and returns a pseudo-random item of the \meta{token list}.
If the \meta{token list} is blank, the result is empty.
%This is not available in older versions of \XeTeX{}.
%\begin{texnote}
%The result is returned within the \tn{unexpanded}
%primitive (\cs{exp_not:n}), which means that the \meta{item}
%does not expand further when appearing in an \texttt{x}-type
%or \texttt{e}-type argument expansion.
%\end{texnote}
\end{function}

\section{Case Functions for Token Lists}

\begin{function}{\TlVarCase}
\begin{syntax}
\cs{TlVarCase} \meta{test token list variable}
~ ~ \verb"{"
~ ~ ~ ~ \meta{token list variable case_1} \Arg{code case_1}
~ ~ ~ ~ \meta{token list variable case_2} \Arg{code case_2}
~ ~ ~ ~ $\cdots$
~ ~ ~ ~ \meta{token list variable case_n} \Arg{code case_n}
~ ~ \verb"}"
\end{syntax}
This function compares the \meta{test token list variable} in turn
with each of the \meta{token list variable cases}. If the two
are equal (as described for \cs{TlVarIfEq})
then the associated \meta{code} is left in the input
stream and other cases are discarded. The function
does nothing if there is no match.
\end{function}

\begin{function}{\TlVarCaseT}
\begin{syntax}
\cs{TlVarCaseT} \meta{test token list variable}
~ ~ \verb"{"
~ ~ ~ ~ \meta{token list variable case_1} \Arg{code case_1}
~ ~ ~ ~ \meta{token list variable case_2} \Arg{code case_2}
~ ~ ~ ~ $\cdots$
~ ~ ~ ~ \meta{token list variable case_n} \Arg{code case_n}
~ ~ \verb"}"
~ ~ \Arg{true code}
\end{syntax}
This function compares the \meta{test token list variable} in turn
with each of the \meta{token list variable cases}. If the two
are equal (as described for \cs{TlVarIfEq})
then the associated \meta{code} is left in the input
stream and other cases are discarded. If any of the
cases are matched, the \meta{true code} is also inserted into the
input stream (after the code for the appropriate case).
\end{function}

\begin{function}{\TlVarCaseF}
\begin{syntax}
\cs{TlVarCaseF} \meta{test token list variable}
~ ~ \verb"{"
~ ~ ~ ~ \meta{token list variable case_1} \Arg{code case_1}
~ ~ ~ ~ \meta{token list variable case_2} \Arg{code case_2}
~ ~ ~ ~ $\cdots$
~ ~ ~ ~ \meta{token list variable case_n} \Arg{code case_n}
~ ~ \verb"}"
~ ~ \Arg{false code}
\end{syntax}
This function compares the \meta{test token list variable} in turn
with each of the \meta{token list variable cases}. If the two
are equal (as described for \cs{TlVarIfEq})
then the associated \meta{code} is left in the input
stream and other cases are discarded. If none
match then the \meta{false code} is inserted into the input stream
 (after the code for the appropriate case).
\end{function}

\begin{function}{\TlVarCaseTF}
\begin{syntax}
\cs{TlVarCaseTF} \meta{test token list variable}
~ ~ \verb"{"
~ ~ ~ ~ \meta{token list variable case_1} \Arg{code case_1}
~ ~ ~ ~ \meta{token list variable case_2} \Arg{code case_2}
~ ~ ~ ~ $\cdots$
~ ~ ~ ~ \meta{token list variable case_n} \Arg{code case_n}
~ ~ \verb"}"
~ ~ \Arg{true code}
~ ~ \Arg{false code}
\end{syntax}
This function compares the \meta{test token list variable} in turn
with each of the \meta{token list variable cases}. If the two
are equal (as described for \cs{TlVarIfEq})
then the associated \meta{code} is left in the input
stream and other cases are discarded. If any of the
cases are matched, the \meta{true code} is also inserted into the
input stream (after the code for the appropriate case), while if none
match then the \meta{false code} is inserted. The function
\cs{TlVarCase}, which does nothing if there is no match, is also
available.
\end{function}

\section{Mapping over Token Lists}

All mappings are done at the current group level, \emph{i.e.} any
local assignments made by the \meta{function} or \meta{code} discussed
below remain in effect after the loop.

%\begin{function}{\TlMapFunction}
%\begin{syntax}
%\cs{TlMapFunction} \Arg{token list} \meta{function}
%\end{syntax}
%Applies \meta{function} to every \meta{item} in the \meta{token list},
%The \meta{function} receives one argument for each iteration.
%This may be a number of tokens if the \meta{item} was stored within
%braces. Hence the \meta{function} should anticipate receiving
%\texttt{n}-type arguments.
%\end{function}
%
%\begin{function}{\TlVarMapFunction}
%\begin{syntax}
%\cs{TlVarMapFunction} \meta{tl var} \meta{function}
%\end{syntax}
%Applies \meta{function} to every \meta{item} in the \meta{tl var}.
%The \meta{function} receives one argument for each iteration.
%This may be a number of tokens if the \meta{item} was stored within
%braces. Hence the \meta{function} should anticipate receiving
%\texttt{n}-type arguments.
%\end{function}

\begin{function}{\TlMapInline}
\begin{syntax}
\cs{TlMapInline} \Arg{token list} \Arg{inline function}
\end{syntax}
Applies the \meta{inline function} to every \meta{item} stored within the
\meta{token list}. The \meta{inline function}  should consist of code which
receives the \meta{item} as \verb|#1|.
\end{function}

\begin{function}{\TlVarMapInline}
\begin{syntax}
\cs{TlVarMapInline} \meta{tl var} \Arg{inline function}
\end{syntax}
Applies the \meta{inline function} to every \meta{item} stored within the
\meta{tl var}. The \meta{inline function} should consist of code which
receives the \meta{item} as \verb|#1|.
\end{function}

%\begin{function}{\TlMapTokens,\TlVarMapTokens}
%\begin{syntax}
%\cs{TlMapTokens} \Arg{tokens} \Arg{code}
%\cs{TlVarMapTokens} \meta{tl var} \Arg{code}
%\end{syntax}
%Analogue of \cs{tl_map_function:NN} which maps several tokens
%instead of a single function.  The \meta{code} receives each \meta{item} in
%the \meta{tl var} or in \meta{tokens} as a trailing brace group. For
%instance,
%\begin{verbatim}
%\tl_map_tokens:Nn \l_my_tl { \prg_replicate:nn { 2 } }
%\end{verbatim}
%expands to twice each \meta{item} in the \meta{tl var}: for each \meta{item} in
%\cs{l_my_tl} the function \cs{prg_replicate:nn} receives |2| and
%\meta{item} as its two arguments.  The function
%\cs{tl_map_inline:Nn} is typically faster but is not expandable.
%\end{function}

\begin{function}{\TlMapVariable}
\begin{syntax}
\cs{TlMapVariable} \Arg{token list} \meta{variable} \Arg{code}
\end{syntax}
Stores each \meta{item} of the \meta{token list} in turn in the
(token list) \meta{variable} and applies the \meta{code}.  The
\meta{code} will usually make use of the \meta{variable}, but this
is not enforced.  The assignments to the \meta{variable} are local.
Its value after the loop is the last \meta{item} in the
\meta{tl var}, or its original value if the \meta{tl var} is blank.
\end{function}

\begin{function}{\TlVarMapVariable}
\begin{syntax}
\cs{TlVarMapVariable} \meta{tl var} \meta{variable} \Arg{code}
\end{syntax}
Stores each \meta{item} of the \meta{tl var} in turn in the (token
list) \meta{variable} and applies the \meta{code}.  The \meta{code}
will usually make use of the \meta{variable}, but this is not
enforced.  The assignments to the \meta{variable} are local.  Its
value after the loop is the last \meta{item} in the \meta{tl var},
or its original value if the \meta{tl var} is blank.
\end{function}

%\begin{function}{\TlMapBreak}
%\begin{syntax}
%\cs{TlMapBreak}
%\end{syntax}
%Used to terminate a tl map function before all
%entries in the \meta{token list variable} have been processed. This
%normally takes place within a conditional statement, for example
%\begin{verbatim}
%\tl_map_inline:Nn \l_my_tl
%{
%\str_if_eq:nnT { #1 } { bingo } { \tl_map_break: }
%Do something useful
%}
%\end{verbatim}
%See also \cs{tl_map_break:n}.
%Use outside of a tl map scenario leads to low
%level \TeX{} errors.
%\begin{texnote}
%When the mapping is broken, additional tokens may be inserted
%before the \meta{tokens} are
%inserted into the input stream.
%This depends on the design of the mapping function.
%\end{texnote}
%\end{function}
%
%\begin{function}{\TlMapBreakDo}
%\begin{syntax}
%\cs{TlMapBreakDo} \Arg{code}
%\end{syntax}
%Used to terminate a tl map function before all
%entries in the \meta{token list variable} have been processed, inserting
%the \meta{code} after the mapping has ended. This
%normally takes place within a conditional statement, for example
%\begin{verbatim}
%\tl_map_inline:Nn \l_my_tl
%{
%\str_if_eq:nnT { #1 } { bingo }
%{ \tl_map_break:n { <code> } }
%Do something useful
%}
%\end{verbatim}
%Use outside of a tl map scenario leads to low
%level \TeX{} errors.
%\begin{texnote}
%When the mapping is broken, additional tokens may be inserted
%before the \meta{code} is
%inserted into the input stream.
%This depends on the design of the mapping function.
%\end{texnote}
%\end{function}

\section{Token List Conditional}

\begin{function}{\TlIfExist,\TlIfExistTF}
\begin{syntax}
\cs{TlIfExist} \meta{tl var}
\cs{TlIfExistTF} \meta{tl var} \Arg{true code} \Arg{false code}
\end{syntax}
Tests whether the \meta{tl var} is currently defined.  This does not
check that the \meta{tl var} really is a token list variable.
\end{function}

\begin{function}{\TlIfEmpty,\TlIfEmptyTF}
\begin{syntax}
\cs{TlIfEmpty} \Arg{token list}
\cs{TlIfEmptyTF} \Arg{token list} \Arg{true code} \Arg{false code}
\end{syntax}
Tests if the \meta{token list} is entirely empty
(\emph{i.e.}~contains no tokens at all). For example
\begin{demohigh}
\TlIfEmptyTF {abc} {\Result{Empty}} {\Result{NonEmpty}}
\TlIfEmptyTF {} {\Result{Empty}} {\Result{NonEmpty}}
\end{demohigh}
\end{function}

\begin{function}{\TlVarIfEmpty,\TlVarIfEmptyTF}
\begin{syntax}
\cs{TlVarIfEmpty} \meta{tl~var}
\cs{TlVarIfEmptyTF} \meta{tl~var} \Arg{true code} \Arg{false code}
\end{syntax}
Tests if the \meta{token list variable} is entirely empty
(\emph{i.e.}~contains no tokens at all). For example
\begin{demohigh}
\TlSet \lTmpaTl {abc}
\TlVarIfEmptyTF \lTmpaTl {\Result{Empty}} {\Result{NonEmpty}}
\TlClear \lTmpaTl
\TlVarIfEmptyTF \lTmpaTl {\Result{Empty}} {\Result{NonEmpty}}
\end{demohigh}
\end{function}

\begin{function}{\TlIfBlank}
\begin{syntax}
\cs{TlIfBlank} \Arg{token list}
\cs{TlIfBlankTF} \Arg{token list} \Arg{true code} \Arg{false code}
\end{syntax}
Tests if the \meta{token list} consists only of blank spaces
(\emph{i.e.} contains no item). The test is \texttt{true} if
\meta{token list} is zero or more explicit space characters
(explicit tokens with character code $32$ and category code $10$),
and is \texttt{false} otherwise.
\end{function}

\begin{function}{\TlIfEq,\TlIfEqTF}
\begin{syntax}
\cs{TlIfEq} \Arg{token list_1} \Arg{token list_2}
\cs{TlIfEqTF} \Arg{token list_1} \Arg{token list_2} \Arg{true code} \Arg{false code}
\end{syntax}
Tests if \meta{token list_1} and \meta{token list_2} contain the
same list of tokens, both in respect of character codes and category
codes. See \cs{StrIfEq} if category codes are not important.
For example
\begin{demohigh}
\TlIfEqTF {abc} {abc} {\Result{Yes}} {\Result{No}}
\TlIfEqTF {abc} {xyz} {\Result{Yes}} {\Result{No}}
\end{demohigh}
%\begin{demohigh}
%\TlSet\lTmpaTl{abc}
%\TlSet\lTmpbTl{abc}
%\TlSet\lTmpcTl{xyz}
%\TlIfEqTF{\TlUse\lTmpaTl}{\TlUse\lTmpbTl}{\Result{Yes}}{\Result{No}}
%\TlIfEqTF{\TlUse\lTmpaTl}{\TlUse\lTmpcTl}{\Result{Yes}}{\Result{No}}
%\end{demohigh}
\end{function}

\begin{function}{\TlVarIfEq,\TlVarIfEqTF}
\begin{syntax}
\cs{TlVarIfEq} \meta{tl var_1} \meta{tl var_2}
\cs{TlVarIfEqTF} \meta{tl var_1} \meta{tl var_2} \Arg{true code} \Arg{false code}
\end{syntax}
Compares the content of two \meta{token list variables} and
is logically \texttt{true} if the two contain the same list of
tokens (\emph{i.e.}~identical in both the list of characters they
contain and the category codes of those characters). For example
\begin{demohigh}
\TlSet \lTmpaTl {abc}
\TlSet \lTmpbTl {abc}
\TlSet \lTmpcTl {xyz}
\TlVarIfEqTF \lTmpaTl \lTmpbTl {\Result{Yes}} {\Result{No}}
\TlVarIfEqTF \lTmpaTl \lTmpcTl {\Result{Yes}} {\Result{No}}
\end{demohigh}
See also \cs{StrVarIfEq} for a comparison that ignores category codes.
\end{function}

\begin{function}{\TlIfIn,\TlIfInTF}
\begin{syntax}
\cs{TlIfIn} \Arg{token list_1} \Arg{token list_2}
\cs{TlIfInTF} \Arg{token list_1} \Arg{token list_2} \Arg{true code} \Arg{false code}
\end{syntax}
Tests if \meta{token list_2} is found inside \meta{token list_1}.
The \meta{token list_2} cannot contain the tokens \verb|{|, \verb|}| or \verb|#|
(more precisely, explicit character tokens with category code $1$
(begin-group) or $2$ (end-group), and tokens with category code $6$).
The search does \emph{not} enter brace (category code $1$/$2$) groups.
\end{function}

\begin{function}{\TlVarIfIn,\TlVarIfInTF}
\begin{syntax}
\cs{TlVarIfIn} \meta{tl var} \Arg{token list}
\cs{TlVarIfInTF} \meta{tl var} \Arg{token list} \Arg{true code} \Arg{false code}
\end{syntax}
Tests if the \meta{token list} is found in the content of the
\meta{tl var}. The \meta{token list} cannot contain
the tokens \verb|{|, \verb|}| or \verb|#|
(more precisely, explicit character tokens with category code $1$
(begin-group) or $2$ (end-group), and tokens with category code $6$).
\end{function}

\begin{function}{\TlIfSingle,\TlIfSingleTF}
\begin{syntax}
\cs{TlIfSingle} \Arg{token list}
\cs{TlIfSingleTF} \Arg{token list} \Arg{true code} \Arg{false code}
\end{syntax}
Tests if the \meta{token list} has exactly one \meta{item}, \emph{i.e.} is
a single normal token (neither an explicit space character nor a
begin-group character) or a single brace group, surrounded by
optional spaces on both sides. In other words, such a token list has
token count $1$ according to \cs{TlCount}.
\end{function}

\begin{function}{\TlVarIfSingle,\TlVarIfSingleTF}
\begin{syntax}
\cs{TlVarIfSingle} \meta{tl var}
\cs{TlVarIfSingleTF} \meta{tl var} \Arg{true code} \Arg{false code}
\end{syntax}
Tests if the content of the \meta{tl var} consists of a single \meta{item},
\emph{i.e.} is a single normal token (neither an explicit space
character nor a begin-group character) or a single brace group,
surrounded by optional spaces on both sides. In other words, such a
token list has token count $1$ according to \cs{TlVarCount}.
\end{function}

\chapter{Strings (\texttt{Str})}

\section{Scratch Variables of Strings}

\begin{variable}{\lTmpaStr,\lTmpbStr,\lTmpcStr,\lTmpiStr,\lTmpjStr,\lTmpkStr}
Scratch strings for local assignment. These are never used by
the \verb!functional! package, and so are safe for use with any
function. However, they may be overwritten by other
code and so should only be used for short-term storage.
\end{variable}

\begin{variable}{\gTmpaStr,\gTmpbStr,\gTmpcStr,\gTmpiStr,\gTmpjStr,\gTmpkStr}
Scratch strings for global assignment. These are never used by
the \verb!functional! package, and so are safe for use with any
function. However, they may be overwritten by other
code and so should only be used for short-term storage.
\end{variable}

\section{Public Functions for Strings}

\begin{function}{\StrNew}
\begin{syntax}
\cs{StrNew} \meta{str var}
\end{syntax}
Creates a new \meta{str var} or raises an error if the name is
already taken. The declaration is global. The \meta{str var} is
initially empty.
\end{function}

\begin{function}{\StrVarLog}
\begin{syntax}
\cs{StrVarLog} \meta{str var}
\end{syntax}
Writes the content of the \meta{str var} in the log file.
For example
\begin{codehigh}
\StrSet\lTmpiStr{1234\abcd5678}
\StrVarLog\lTmpiStr
\end{codehigh}
\end{function}

\begin{function}{\StrVarShow}
\begin{syntax}
\cs{StrVarShow} \meta{str var}
\end{syntax}
Displays the content of the \meta{str var} on the terminal.
\end{function}

\begin{function}{\StrUse}
\begin{syntax}
\cs{StrUse} \meta{str var}
\end{syntax}
Recovers the content of a \meta{str var} and returns the value.
An error is raised if the variable
does not exist or if it is invalid. Note that it is possible to use
a \meta{str} directly without an accessor function.
\end{function}

\begin{function}{\StrSet}
\begin{syntax}
\cs{StrSet} \meta{str var} \Arg{token list}
\end{syntax}
Converts the \meta{token list} to a \meta{string}, and stores the
result in \meta{str var}. For example
\begin{demohigh}
\StrSet\lTmpiStr{\IntMathMult{4}{5}}
\StrUse\lTmpiStr
\end{demohigh}
\end{function}

\begin{function}{\StrClear}
\begin{syntax}
\cs{StrClear} \meta{str var}
\end{syntax}
Clears the content of the \meta{str var}. For example
\begin{demohigh}
\StrSet\lTmpjStr{One}
\StrClear\lTmpjStr
\StrSet\lTmpjStr{Two}
\StrUse\lTmpjStr
\end{demohigh}
\end{function}

\begin{function}{\StrPutLeft}
\begin{syntax}
\cs{StrPutLeft} \meta{str var} \Arg{token list}
\end{syntax}
Converts the \meta{token list} to a \meta{string}, and prepends the
result to \meta{str var}.  The current contents of the \meta{str
var} are not automatically converted to a string. For example
\begin{demohigh}
\StrSet\lTmpkStr{Functional}
\StrPutLeft\lTmpkStr{Hello}
\StrUse\lTmpkStr
\end{demohigh}
\end{function}

\begin{function}{\StrPutRight}
\begin{syntax}
\cs{StrPutRight} \meta{str var} \Arg{token list}
\end{syntax}
Converts the \meta{token list} to a \meta{string}, and appends the
result to \meta{str var}.  The current contents of the \meta{str
var} are not automatically converted to a string. For example
\begin{demohigh}
\StrSet\lTmpkStr{Functional}
\StrPutRight\lTmpkStr{World}
\StrUse\lTmpkStr
\end{demohigh}
\end{function}

\begin{function}{\StrVarIfEmpty,\StrVarIfEmptyTF}
\begin{syntax}
\cs{StrVarIfEmpty} \meta{str var}
\cs{StrVarIfEmptyTF} \meta{str var} \Arg{true code} \Arg{false code}
\end{syntax}
Tests if the \meta{string variable} is entirely empty
(\emph{i.e.} contains no characters at all). For example
\begin{demohigh}
\StrSet\lTmpaStr{abc}
\StrVarIfEmptyTF\lTmpaStr{\Result{Empty}}{\Result{NonEmpty}}
\StrClear\lTmpaStr
\StrVarIfEmptyTF\lTmpaStr{\Result{Empty}}{\Result{NonEmpty}}
\end{demohigh}
\end{function}

\begin{function}{\StrIfEq,\StrIfEqTF}
\begin{syntax}
\cs{StrIfEq} \Arg{tl_1} \Arg{tl_2}
\cs{StrIfEqTF} \Arg{tl_1} \Arg{tl_2} \Arg{true code} \Arg{false code}
\end{syntax}
Compares the two \meta{token lists} on a character by character
basis (namely after converting them to strings),
and is \texttt{true} if the two \meta{strings} contain the same
characters in the same order.
%Thus for example
%\begin{codehigh}
%\StrIfEq{abc}{\TlToStr{abc}}
%\end{codehigh}
%is logically \texttt{true}.
See \cs{TlIfEq} to compare
tokens (including their category codes) rather than characters.
For example
\begin{demohigh}
\StrIfEqTF{abc}{abc}{\Result{Yes}}{\Result{No}}
\StrIfEqTF{abc}{xyz}{\Result{Yes}}{\Result{No}}
\end{demohigh}
%\begin{demohigh}
%\StrSet\lTmpaStr{abc}
%\StrSet\lTmpbStr{abc}
%\StrSet\lTmpcStr{xyz}
%\StrIfEqTF{\lTmpaStr}{\lTmpbStr}{\Result{Yes}}{\Result{No}}
%\StrIfEqTF{\lTmpaStr}{\lTmpcStr}{\Result{Yes}}{\Result{No}}
%\StrIfEqTF{\StrUse\lTmpaStr}{\StrUse\lTmpbStr}{\Result{Yes}}{\Result{No}}
%\StrIfEqTF{\StrUse\lTmpaStr}{\StrUse\lTmpcStr}{\Result{Yes}}{\Result{No}}
%\end{demohigh}
\end{function}

\begin{function}{\StrVarIfEq,\StrVarIfEqTF}
\begin{syntax}
\cs{StrVarIfEq} \meta{str var_1} \meta{str var_2}
\cs{StrVarIfEqTF} \meta{str var_1} \meta{str var_2} \Arg{true code} \Arg{false code}
\end{syntax}
Compares the content of two \meta{str variables} and
is logically \texttt{true} if the two contain the same characters
in the same order.  See \cs{TlVarIfEq} to compare tokens
(including their category codes) rather than characters.
\begin{demohigh}
\StrSet\lTmpaStr{abc}
\StrSet\lTmpbStr{abc}
\StrSet\lTmpcStr{xyz}
\StrVarIfEqTF\lTmpaStr\lTmpbStr{\Result{Yes}}{\Result{No}}
\StrVarIfEqTF\lTmpaStr\lTmpcStr{\Result{Yes}}{\Result{No}}
\end{demohigh}
\end{function}

\chapter{Integers (\texttt{Int})}

\section{Scratch Variables of Integers}

\begin{variable}{\lTmpaInt,\lTmpbInt,\lTmpcInt,\lTmpiInt,\lTmpjInt,\lTmpkInt}
Scratch integer for local assignment. These are never used by
the \verb!functional! package, and so are safe for use with any
function. However, they may be overwritten by other
code and so should only be used for short-term storage.
\end{variable}

\begin{variable}{\gTmpaInt,\gTmpbInt,\gTmpcInt,\gTmpiInt,\gTmpjInt,\gTmpkInt}
Scratch integer for global assignment. These are never used by
the \verb!functional! package, and so are safe for use with any
function. However, they may be overwritten by other
code and so should only be used for short-term storage.
\end{variable}

\section{Public Functions for Integers}

\begin{function}{\IntEval}
\begin{syntax}
\cs{IntEval} \Arg{integer expression}
\end{syntax}
Evaluates the \meta{integer expression} and returns the result:
for positive results an
explicit sequence of decimal digits not starting with~\texttt{0},
for negative results \texttt{-}~followed by such a sequence, and
\texttt{0}~for zero. For example
\begin{demohigh}
\IntEval{(1+4)*(2-3)/5}
\end{demohigh}
\end{function}

\begin{function}{\IntMathAdd}
\begin{syntax}
\cs{IntMathAdd} \Arg{integer expression_1} \Arg{integer expression_2}
\end{syntax}
Adds \Arg{integer expression_1} and \Arg{integer expression_2},
and returns the result. For example
\begin{demohigh}
\IntMathAdd{7}{3}
\end{demohigh}
\end{function}

\begin{function}{\IntMathSub}
\begin{syntax}
\cs{IntMathSub} \Arg{integer expression_1} \Arg{integer expression_2}
\end{syntax}
Subtracts \Arg{integer expression_2} from \Arg{integer expression_1},
and returns the result. For example
\begin{demohigh}
\IntMathSub{7}{3}
\end{demohigh}
\end{function}

\begin{function}{\IntMathMult}
\begin{syntax}
\cs{IntMathMult} \Arg{integer expression_1} \Arg{integer expression_2}
\end{syntax}
Multiplies \Arg{integer expression_1} by \Arg{integer expression_2},
and returns the result. For example
\begin{demohigh}
\IntMathMult{7}{3}
\end{demohigh}
\end{function}

\begin{function}{\IntMathDiv}
\begin{syntax}
\cs{IntMathDiv} \Arg{integer expression_1} \Arg{integer expression_2}
\end{syntax}
Divides \Arg{integer expression_1} by \Arg{integer expression_2},
and returns the result. For example
\begin{demohigh}
\IntMathDiv{7}{3}
\end{demohigh}
\end{function}

\begin{function}{\IntNew}
\begin{syntax}
\cs{IntNew} \meta{integer}
\end{syntax}
Creates a new \meta{integer} or raises an error if the name is
already taken. The declaration is global. The \meta{integer} is
initially equal to $0$.
\end{function}

\begin{function}{\IntUse}
\begin{syntax}
\cs{IntUse} \meta{integer}
\end{syntax}
Recovers the content of an \meta{integer} and returns the value.
An error is raised if the variable does not exist or if it is invalid.
\end{function}

\begin{function}{\IntSet}
\begin{syntax}
\cs{IntSet} \meta{integer} \Arg{integer expression}
\end{syntax}
Sets \meta{integer} to the value of \meta{integer expression},
which must evaluate to an integer (as described for \cs{IntEval}).
For example
\begin{demohigh}
\IntSet\lTmpaInt{3+5}
\IntUse\lTmpaInt
\end{demohigh}
\end{function}

\begin{function}{\IntZero}
\begin{syntax}
\cs{IntZero} \meta{integer}
\end{syntax}
Sets \meta{integer} to $0$. For example
\begin{demohigh}
\IntSet\lTmpaInt{5}
\IntZero\lTmpaInt
\IntUse\lTmpaInt
\end{demohigh}
\end{function}

\begin{function}{\IntIncr}
\begin{syntax}
\cs{IntIncr} \meta{integer}
\end{syntax}
Increases the value stored in \meta{integer} by $1$.
For example
\begin{demohigh}
\IntSet\lTmpaInt{5}
\IntIncr\lTmpaInt
\IntUse\lTmpaInt
\end{demohigh}
\end{function}

\begin{function}{\IntDecr}
\begin{syntax}
\cs{IntDecr} \meta{integer}
\end{syntax}
Decreases the value stored in \meta{integer} by $1$.
For example
\begin{demohigh}
\IntSet\lTmpaInt{5}
\IntDecr\lTmpaInt
\IntUse\lTmpaInt
\end{demohigh}
\end{function}

\begin{function}{\IntAdd}
\begin{syntax}
\cs{IntAdd} \meta{integer} \Arg{integer expression}
\end{syntax}
Adds the result of the \meta{integer expression} to the current
content of the \meta{integer}. For example
\begin{demohigh}
\IntSet\lTmpaInt{5}
\IntAdd\lTmpaInt{2}
\IntUse\lTmpaInt
\end{demohigh}
\end{function}

\begin{function}{\IntSub}
\begin{syntax}
\cs{IntSub} \meta{integer} \Arg{integer expression}
\end{syntax}
Subtracts the result of the \meta{integer expression} from the
current content of the \meta{integer}. For example
\begin{demohigh}
\IntSet\lTmpaInt{5}
\IntSub\lTmpaInt{3}
\IntUse\lTmpaInt
\end{demohigh}
\end{function}

\begin{function}{\IntStepVariable}
\begin{syntax}
\cs{IntStepVariable} \Arg{initial value} \Arg{step} \Arg{final value} \meta{tl~var} \Arg{code}
\end{syntax}
This function first evaluates the \meta{initial value}, \meta{step}
and \meta{final value}, all of which should be integer expressions.
Then for each \meta{value} from the \meta{initial value} to the
\meta{final value} in turn (using \meta{step} between each
\meta{value}), the \meta{code} is evaluated,
with the \meta{tl~var} defined as the current \meta{value}.  Thus
the \meta{code} should make use of the \meta{tl~var}.
For example
\begin{demohigh}
\IgnoreSpacesOn
\TlClear\lTmpaTl
\IntStepVariable{1}{3}{30}\lTmpiTl{
  \TlPutRight\lTmpaTl{\Value\lTmpiTl}
  \TlPutRight\lTmpaTl{~}
}
\Result{\Value\lTmpaTl}
\IgnoreSpacesOff
\end{demohigh}
\end{function}

\begin{function}{\IntCompare,\IntCompareTF}
\begin{syntax}
\cs{IntCompare} \Arg{intexpr_1} \meta{relation} \Arg{intexpr_2}
\cs{IntCompareTF} \Arg{intexpr_1} \meta{relation} \Arg{intexpr_2} \Arg{true code} \Arg{false code}
\end{syntax}
This function first evaluates each of the \meta{integer expressions}
as described for \cs{IntEval}. The two results are then
compared using the \meta{relation}:\par
{\centering\begin{tabular}{ll}
Equal        & \texttt{=} \\
Greater than & \texttt{>} \\
Less than    & \texttt{<} \\
\end{tabular}\par}
For example
\begin{demohigh}
\IntCompareTF{2}>{1}{\Result{Greater}}{\Result{Less}}
\IntCompareTF{2}>{3}{\Result{Greater}}{\Result{Less}}
\end{demohigh}
\end{function}

\chapter{Floating Point Numbers (\texttt{Fp})}

\section{Scratch Variables of Floating Point Numbers}

\begin{variable}{\lTmpaFp,\lTmpbFp,\lTmpcFp,\lTmpiFp,\lTmpjFp,\lTmpkFp}
Scratch floating point numbers for local assignment. These are never used by
the \verb!functional! package, and so are safe for use with any
function. However, they may be overwritten by other
code and so should only be used for short-term storage.
\end{variable}

\begin{variable}{\gTmpaFp,\gTmpbFp,\gTmpcFp,\gTmpiFp,\gTmpjFp,\gTmpkFp}
Scratch floating point numbers for global assignment. These are never used by
the \verb!functional! package, and so are safe for use with any
function. However, they may be overwritten by other
code and so should only be used for short-term storage.
\end{variable}

\section{Public Functions for Floating Point Numbers}

\begin{function}{\FpEval}
\begin{syntax}
\cs{FpEval} \Arg{floating point expression}
\end{syntax}
Evaluates the \meta{floating point expression} and returns the
result as a decimal number with no
exponent.  Leading or trailing zeros may be inserted to compensate
for the exponent.  Non-significant trailing zeros are trimmed, and
integers are expressed without a decimal separator.  The values
$\pm\infty$ and \nan{} trigger an \enquote{invalid operation}
exception.
For a tuple, each item is converted using \cs{FpEval} and they are combined as
\verb|(|\meta{fp_1}\verb*|, |\meta{fp_2}\verb*|, |\ldots{}\meta{fp_n}\verb|)|
if $n>1$ and \verb|(|\meta{fp_1}\verb|,)| or \verb|()| for fewer items.
%This function is identical to \cs{fp_to_decimal:n}.
For example
\begin{demohigh}
\FpEval{(1.2+3.4)*(5.6-7.8)/9}
\end{demohigh}
\end{function}

\begin{function}{\FpMathAdd}
\begin{syntax}
\cs{FpMathAdd} \Arg{fpexpr_1} \Arg{fpexpr_2}
\end{syntax}
Adds \Arg{fpexpr_1} and \Arg{fpexpr_2},
and returns the result. For example
\begin{demohigh}
\FpMathAdd{2.8}{3.7}
\FpMathAdd{3.8-1}{2.7+1}
\end{demohigh}
\end{function}

\begin{function}{\FpMathSub}
\begin{syntax}
\cs{FpMathSub} \Arg{fpexpr_1} \Arg{fpexpr_2}
\end{syntax}
Subtracts \Arg{fpexpr_2} from \Arg{fpexpr_1},
and returns the result. For example
\begin{demohigh}
\FpMathSub{2.8}{3.7}
\FpMathSub{3.8-1}{2.7+1}
\end{demohigh}
\end{function}

\begin{function}{\FpMathMult}
\begin{syntax}
\cs{FpMathMult} \Arg{fpexpr_1} \Arg{fpexpr_2}
\end{syntax}
Multiplies \Arg{fpexpr_1} by \Arg{fpexpr_2},
and returns the result. For example
\begin{demohigh}
\FpMathMult{2.8}{3.7}
\FpMathMult{3.8-1}{2.7+1}
\end{demohigh}
\end{function}

\begin{function}{\FpMathDiv}
\begin{syntax}
\cs{FpMathDiv} \Arg{fpexpr_1} \Arg{fpexpr_2}
\end{syntax}
Divides \Arg{fpexpr_1} by \Arg{fpexpr_2},
and returns the result. For example
\begin{demohigh}
\FpMathDiv{2.8}{3.7}
\FpMathDiv{3.8-1}{2.7+1}
\end{demohigh}
\end{function}

\begin{function}{\FpMathSign}
\begin{syntax}
\cs{FpMathSign} \Arg{fpexpr}
\end{syntax}
Evaluates the \meta{fpexpr} and returns the value
using \cs{FpEval}\verb|{sign(|\meta{result}\verb|)}|: $+1$ for positive
numbers and for $+\infty$, $-1$ for negative numbers and for
$-\infty$, $\pm 0$ for $\pm 0$.  If the operand is a tuple or is
\nan{}, then \enquote{invalid operation} occurs and the result
is $0$. For example
\begin{demohigh}
\FpMathSign{3.5}
\FpMathSign{-2.7}
\end{demohigh}
\end{function}

\begin{function}{\FpNew}
\begin{syntax}
\cs{FpNew} \meta{fp var}
\end{syntax}
Creates a new \meta{fp var} or raises an error if the name is
already taken. The declaration is global. The \meta{fp~var} is
initially $+0$.
\end{function}

\begin{function}{\FpVarLog}
\begin{syntax}
\cs{FpVarLog} \meta{fp var}
\end{syntax}
Writes the value of \meta{fp var} in the log file.
\end{function}

\begin{function}{\FpVarShow}
\begin{syntax}
\cs{FpVarShow} \meta{fp var}
\end{syntax}
Displays the value of \meta{fp var} in the terminal.
\end{function}

\begin{function}{\FpUse}
\begin{syntax}
\cs{FpUse} \meta{fp var}
\end{syntax}
Recovers the value of the \meta{fp var} and returns the value as a
decimal number with no exponent.
%Leading or trailing zeros may be inserted to compensate for the
%exponent.  Non-significant trailing zeros are trimmed.  Integers are
%expressed without a decimal separator.  The values $\pm\infty$
%and \nan{} trigger an \enquote{invalid operation} exception.
%For a tuple, each item is converted using \cs{fp_to_decimal:n} and they are combined as
%|(|\meta{fp_1}\verb*|, |\meta{fp_2}\verb*|, |\ldots{}\meta{fp_n}|)|
%if $n>1$ and |(|\meta{fp_1}|,)| or |()| for fewer items.
%This function is identical to \cs{fp_to_decimal:N}.
\end{function}

\begin{function}{\FpConst}
\begin{syntax}
\cs{FpConst} \meta{fp var} \Arg{floating point expression}
\end{syntax}
Creates a new constant \meta{fp var} or raises an error if the name
is already taken. The \meta{fp var} is set globally equal to
the result of evaluating the \meta{floating point expression}.
For example
\begin{demohigh}
\FpConst\cMyPiFp{3.1415926}
\FpUse\cMyPiFp
\end{demohigh}
\end{function}

\begin{function}{\FpSet}
\begin{syntax}
\cs{FpSet} \meta{fp var} \Arg{floating point expression}
\end{syntax}
Sets \meta{fp var} equal to the result of computing the
\meta{floating point expression}. For example
\begin{demohigh}
\FpSet\lTmpaFp{4/7}
\FpUse\lTmpaFp
\end{demohigh}
\end{function}

\begin{function}{\FpZero}
\begin{syntax}
\cs{FpZero} \meta{fp var}
\end{syntax}
Sets the \meta{fp var} to $+0$. For example
\begin{demohigh}
\FpSet\lTmpaFp{5.3}
\FpZero\lTmpaFp
\FpUse\lTmpaFp
\end{demohigh}
\end{function}

\begin{function}{\FpAdd}
\begin{syntax}
\cs{FpAdd} \meta{fp var} \Arg{floating point expression}
\end{syntax}
Adds the result of computing the \meta{floating point expression} to
the \meta{fp var}.
This also applies if \meta{fp var} and \meta{floating point
expression} evaluate to tuples of the same size. For example
\begin{demohigh}
\FpSet\lTmpaFp{5.3}
\FpAdd\lTmpaFp{2.11}
\FpUse\lTmpaFp
\end{demohigh}
\end{function}

\begin{function}{\FpSub}
\begin{syntax}
\cs{FpSub} \meta{fp var} \Arg{floating point expression}
\end{syntax}
Subtracts the result of computing the \meta{floating point
expression} from the \meta{fp var}.
This also applies if \meta{fp var} and \meta{floating point
expression} evaluate to tuples of the same size. For example
\begin{demohigh}
\FpSet\lTmpaFp{5.3}
\FpSub\lTmpaFp{2.11}
\FpUse\lTmpaFp
\end{demohigh}
\end{function}

\begin{function}{\FpStepVariable}
\begin{syntax}
\cs{FpStepVariable} \Arg{initial value} \Arg{step} \Arg{final value} \meta{tl var} \Arg{code}
\end{syntax}
This function first evaluates the \meta{initial value}, \meta{step}
and \meta{final value}, all of which should be floating point
expressions evaluating to a floating point number, not a tuple.
Then for each \meta{value} from the \meta{initial value} to the
\meta{final value} in turn (using \meta{step} between each
\meta{value}), the \meta{code} is inserted into the input stream,
with the \meta{tl var} defined as the current \meta{value}.  Thus
the \meta{code} should make use of the \meta{tl var}.
For example
\begin{demohigh}
\IgnoreSpacesOn
\TlClear\lTmpaTl
\FpStepVariable{1}{0.1}{1.5}\lTmpiTl{
  \TlPutRight\lTmpaTl{\Value\lTmpiTl}
  \TlPutRight\lTmpaTl{~}
}
\Result{\Value\lTmpaTl}
\IgnoreSpacesOff
\end{demohigh}
\end{function}

\begin{function}{\FpIfExist,\FpIfExistTF}
\begin{syntax}
\cs{FpIfExist} \meta{fp var}
\cs{FpIfExistTF} \meta{fp var} \Arg{true code} \Arg{false code}
\end{syntax}
Tests whether the \meta{fp var} is currently defined.  This does not
check that the \meta{fp var} really is a floating point variable.
For example
\begin{demohigh}
\FpIfExistTF\lTmpaFp{\Result{Yes}}{\Result{No}}
\FpIfExistTF\lMyUndefinedFp{\Result{Yes}}{\Result{No}}
\end{demohigh}
\end{function}

\begin{function}{\FpCompare,\FpCompareTF}
\begin{syntax}
\cs{FpCompare} \Arg{fpexpr_1} \meta{relation} \Arg{fpexpr_2}
\cs{FpCompareTF} \Arg{fpexpr_1} \meta{relation} \Arg{fpexpr_2} \Arg{true code} \Arg{false code}
\end{syntax}
Compares the \meta{fpexpr_1} and the \meta{fpexpr_2}, and returns
\texttt{true} if the \meta{relation} is obeyed. For example
\begin{demohigh}
\FpCompareTF{1}>{0.9999}{\Result{Greater}}{\Result{Less}}
\FpCompareTF{1}>{1.0001}{\Result{Greater}}{\Result{Less}}
\end{demohigh}
Two floating points
$x$ and $y$ may obey four mutually exclusive relations:
$x<y$, $x=y$, $x>y$, or $x?y$ (\enquote{not ordered}).  The last
case occurs exactly if one or both operands is \nan{} or is a tuple,
unless they are equal tuples.  Note that a \nan{} is distinct from
any value, even another \nan{}, hence $x=x$ is not true for
a \nan{}.  To test if a value is \nan{}, compare it to an arbitrary
number with the \enquote{not ordered} relation.\par
%\begin{demohigh}
%\FpCompareTF{0/0}?{0}{\Result{Is~a~Nan}}{\Result{Isn't~a~NaN}}
%\end{demohigh}
Tuples are equal if they have the same number of items and items
compare equal (in particular there must be no \nan{}).
At present any other comparison with tuples yields \verb|?| (not ordered).
This is experimental.
\end{function}

\chapter{Dimensions (\texttt{Dim})}

\section{Scratch and Constant Dimensions}

\begin{variable}{\lTmpaDim,\lTmpbDim,\lTmpcDim,\lTmpiDim,\lTmpjDim,\lTmpkDim}
Scratch dimensions for local assignment. These are never used by
the \verb!functional! package, and so are safe for use with any
function. However, they may be overwritten by other
code and so should only be used for short-term storage.
\end{variable}

\begin{variable}{\gTmpaDim,\gTmpbDim,\gTmpcDim,\gTmpiDim,\gTmpjDim,\gTmpkDim}
Scratch dimensions for global assignment. These are never used by
the \verb!functional! package, and so are safe for use with any
function. However, they may be overwritten by other
code and so should only be used for short-term storage.
\end{variable}

\begin{variable}{\cMaxDim}
The maximum value that can be stored as a dimension.  This can also
be used as a component of a skip.
\end{variable}

\begin{variable}{\cZeroDim}
A zero length as a dimension.  This can also be used as a component
of a skip.
\end{variable}

\section{Public Functions for Dimensions}

\begin{function}{\DimEval}
\begin{syntax}
\cs{DimEval} \Arg{dimension expression}
\end{syntax}
Evaluates the \meta{dimension expression}, expanding any
dimensions and token list variables within the \meta{expression}
to their content (without requiring \cs{DimUse}/\cs{TlUse})
and applying the standard mathematical rules. The result of the
calculation is returned as a \meta{dimension denotation}.
%This is expressed in points (\texttt{pt}), and requires suitable
%termination if used in a \TeX{}-style assignment as it is \emph{not}
%an \meta{internal dimension}.
For example
\begin{demohigh}
\DimEval{(1.2pt+3.4pt)/9}
\end{demohigh}
%\DimEval{(1.2pt+3.4pt)*(5.6-7.8)/9}
\end{function}

\begin{function}{\DimMathAdd}
\begin{syntax}
\cs{DimMathAdd} \Arg{dimexpr_1} \Arg{dimexpr_2}
\end{syntax}
Adds \Arg{dimexpr_1} and \Arg{dimexpr_2},
and returns the result. For example
\begin{demohigh}
\DimMathAdd{2.8pt}{3.7pt}
\DimMathAdd{3.8pt-1pt}{2.7pt+1pt}
\end{demohigh}
\end{function}

\begin{function}{\DimMathSub}
\begin{syntax}
\cs{DimMathSub} \Arg{dimexpr_1} \Arg{dimexpr_2}
\end{syntax}
Subtracts \Arg{dimexpr_2} from \Arg{dimexpr_1},
and returns the result. For example
\begin{demohigh}
\DimMathSub{2.8pt}{3.7pt}
\DimMathSub{3.8pt-1pt}{2.7pt+1pt}
\end{demohigh}
\end{function}

\begin{function}{\DimMathRatio}
\begin{syntax}
\cs{DimMathRatio} \Arg{dimexpr_1} \Arg{dimexpr_2}
\end{syntax}
Parses the two \meta{dimension expressions},
then calculates the ratio of the two and returns it.
The result is a ratio expression
between two integers, with all distances converted to scaled points.
For example
\begin{demohigh}
\DimMathRatio{5pt}{10pt}
\end{demohigh}
The returned value is suitable for use inside a \meta{dimension expression}
such as
\begin{codehigh}
\DimSet\lTmpaDim{10pt*\DimMathRatio{5pt}{10pt}}
\end{codehigh}
\end{function}

\begin{function}{\DimMathSign}
\begin{syntax}
\cs{DimMathSign} \Arg{dimexpr}
\end{syntax}
Evaluates the \meta{dimexpr} then returns $1$ or $0$ or $-1$
according to the sign of the result. For example
\begin{demohigh}
\DimMathSign{3.5pt}
\DimMathSign{-2.7pt}
\end{demohigh}
\end{function}

\begin{function}{\DimMathAbs}
\begin{syntax}
\cs{DimMathAbs} \Arg{dimexpr}
\end{syntax}
Converts the \meta{dimexpr} to its absolute value,
returning the result as a \meta{dimension denotation}.
For example
\begin{demohigh}
\DimMathAbs{3.5pt}
\DimMathAbs{-2.7pt}
\end{demohigh}
\end{function}

\begin{function}{\DimMathMax,\DimMathMin}
\begin{syntax}
\cs{DimMathMax} \Arg{dimexpr_1} \Arg{dimexpr_2}
\cs{DimMathMin} \Arg{dimexpr_1} \Arg{dimexpr_2}
\end{syntax}
Evaluates the two \meta{dimension expressions} and returns either the
maximum or minimum value as appropriate as a \meta{dimension denotation}.
For example
\begin{demohigh}
\DimMathMax{3.5pt}{-2.7pt}
\DimMathMin{3.5pt}{-2.7pt}
\end{demohigh}
\end{function}

\begin{function}{\DimNew}
\begin{syntax}
\cs{DimNew} \meta{dimension}
\end{syntax}
Creates a new \meta{dimension} or raises an error if the name is
already taken. The declaration is global. The \meta{dimension}
is initially equal to $0$\,pt.
\end{function}

\begin{function}{\DimLog}
\begin{syntax}
\cs{DimLog} \Arg{dimension expression}
\end{syntax}
Writes the result of evaluating the \meta{dimension expression}
in the log file. For example
\begin{codehigh}
\DimLog{\lFooSomeDim+1cm}
\end{codehigh}
\end{function}

\begin{function}{\DimVarLog}
\begin{syntax}
\cs{DimVarLog} \meta{dimension}
\end{syntax}
Writes the value of the \meta{dimension} in the log file. For example
\begin{codehigh}
\DimVarLog\lFooSomeDim
\end{codehigh}
\end{function}

\begin{function}{\DimShow}
\begin{syntax}
\cs{DimShow} \Arg{dimension expression}
\end{syntax}
Displays the result of evaluating the \meta{dimension expression}
on the terminal. For example
\begin{codehigh}
\DimShow{\lFooSomeDim+1cm}
\end{codehigh}
\end{function}

\begin{function}{\DimVarShow}
\begin{syntax}
\cs{DimVarShow} \meta{dimension}
\end{syntax}
Displays the value of the \meta{dimension} on the terminal. For example
\begin{codehigh}
\DimVarShow\lFooSomeDim
\end{codehigh}
\end{function}

\begin{function}{\DimUse}
\begin{syntax}
\cs{DimUse} \meta{dimension}
\end{syntax}
Recovers the content of a \meta{dimension} and returns the value.
An error is raised if the variable does not exist or if it is invalid.
\end{function}

\begin{function}{\DimConst}
\begin{syntax}
\cs{DimConst} \meta{dimension} \Arg{dimension expression}
\end{syntax}
Creates a new constant \meta{dimension} or raises an error if the
name is already taken. The value of the \meta{dimension} is set
globally to the \meta{dimension expression}. For example
\begin{demohigh}
\DimConst\cFooSomeDim{1cm}
\DimUse\cFooSomeDim
\end{demohigh}
\end{function}

\begin{function}{\DimSet}
\begin{syntax}
\cs{DimSet} \meta{dimension} \Arg{dimension expression}
\end{syntax}
Sets \meta{dimension} to the value of \meta{dimension expression}, which
must evaluate to a length with units.
\end{function}

\begin{function}{\DimSetEq}
\begin{syntax}
\cs{DimSetEq} \meta{dimension_1} \meta{dimension_2}
\end{syntax}
Sets the content of \meta{dimension_1} equal to that of
\meta{dimension_2}. For example
\begin{demohigh}
\DimSet\lTmpaDim{10pt}
\DimSetEq\lTmpbDim\lTmpaDim
\DimUse\lTmpbDim
\end{demohigh}
\end{function}

\begin{function}{\DimZero}
\begin{syntax}
\cs{DimZero} \meta{dimension}
\end{syntax}
Sets \meta{dimension} to $0$\,pt. For example
\begin{demohigh}
\DimSet\lTmpaDim{1em}
\DimZero\lTmpaDim
\DimUse\lTmpaDim
\end{demohigh}
\end{function}

\begin{function}{\DimZeroNew}
\begin{syntax}
\cs{DimZeroNew} \meta{dimension}
\end{syntax}
Ensures that the \meta{dimension} exists globally by applying
\cs{DimNew} if necessary, then applies
\cs{DimZero} to set the \meta{dimension} to zero. For example
\begin{demohigh}
\DimZeroNew\lFooSomeDim
\DimUse\lFooSomeDim
\end{demohigh}
\end{function}

\begin{function}{\DimAdd}
\begin{syntax}
\cs{DimAdd} \meta{dimension} \Arg{dimension expression}
\end{syntax}
Adds the result of the \meta{dimension expression} to the current
content of the \meta{dimension}. For example
\begin{demohigh}
\DimSet\lTmpaDim{5.3pt}
\DimAdd\lTmpaDim{2.11pt}
\DimUse\lTmpaDim
\end{demohigh}
\end{function}

\begin{function}{\DimSub}
\begin{syntax}
\cs{DimSub} \meta{dimension} \Arg{dimension expression}
\end{syntax}
Subtracts the result of the \meta{dimension expression} from the
current content of the \meta{dimension}. For example
\begin{demohigh}
\DimSet\lTmpaDim{5.3pt}
\DimSub\lTmpaDim{2.11pt}
\DimUse\lTmpaDim
\end{demohigh}
\end{function}

\begin{function}{\DimStepVariable}
\begin{syntax}
\cs{DimStepVariable} \Arg{initial value} \Arg{step} \Arg{final value} \meta{tl var} \Arg{code}
\end{syntax}
This function first evaluates the \meta{initial value}, \meta{step}
and \meta{final value}, all of which should be dimension expressions.
Then for each \meta{value} from the \meta{initial value} to the
\meta{final value} in turn (using \meta{step} between each
\meta{value}), the \meta{code} is inserted into the input stream,
with the \meta{tl var} defined as the current \meta{value}.  Thus
the \meta{code} should make use of the \meta{tl var}.
For example
\begin{demohigh}
\IgnoreSpacesOn
\TlClear\lTmpaTl
\DimStepVariable{1pt}{0.1pt}{1.5pt}\lTmpiTl{
  \TlPutRight\lTmpaTl{\Value\lTmpiTl}
  \TlPutRight\lTmpaTl{~}
}
\Result{\Value\lTmpaTl}
\IgnoreSpacesOff
\end{demohigh}
\end{function}

\begin{function}{\DimIfExist,\DimIfExistTF}
\begin{syntax}
\cs{DimIfExist} \meta{dimension}
\cs{DimIfExistTF} \meta{dimension} \Arg{true code} \Arg{false code}
\end{syntax}
Tests whether the \meta{dimension} is currently defined.  This does
not check that the \meta{dimension} really is a dimension variable.
For example
\begin{demohigh}
\DimIfExistTF\lTmpaDim{\Result{Yes}}{\Result{No}}
\DimIfExistTF\lFooUndefinedDim{\Result{Yes}}{\Result{No}}
\end{demohigh}
\end{function}

\begin{function}{\DimCompare,\DimCompareTF}
\begin{syntax}
\cs{DimCompare} \Arg{dimexpr_1} \meta{relation} \Arg{dimexpr_2}
\cs{DimCompareTF} \Arg{dimexpr_1} \meta{relation} \Arg{dimexpr_2} \Arg{true code} \Arg{false code}
\end{syntax}
This function first evaluates each of the \meta{dimension expressions}
as described for \cs{DimEval}. The two results are then
compared using the \meta{relation}:\par
{\centering
\begin{tabular}{ll}
Equal        & \verb|=| \\
Greater than & \verb|>| \\
Less than    & \verb|<| \\
\end{tabular}\par}
For example
\begin{demohigh}
\DimCompareTF{1pt}>{0.9999pt}{\Result{Greater}}{\Result{Less}}
\DimCompareTF{1pt}>{1.0001pt}{\Result{Greater}}{\Result{Less}}
\end{demohigh}
\end{function}

\begin{function}{\DimCase}
\begin{syntax}
\cs{DimCase} \Arg{test dimension expression}
~ ~ \verb|{|
~ ~ ~ ~ \Arg{dimexpr case_1} \Arg{code case_1}
~ ~ ~ ~  \Arg{dimexpr case_2} \Arg{code case_2}
~ ~ ~ ~ \ldots
~ ~ ~ ~ \Arg{dimexpr case_n} \Arg{code case_n}
~ ~ \verb|}|
\end{syntax}
This function evaluates the \meta{test dimension expression} and
compares this in turn to each of the
\meta{dimension expression cases}. If the two are equal then the
associated \meta{code} is left in the input stream
and other cases are discarded.
\end{function}

\begin{function}{\DimCaseT}
\begin{syntax}
\cs{DimCaseT} \Arg{test dimension expression}
~ ~ \verb|{|
~ ~ ~ ~ \Arg{dimexpr case_1} \Arg{code case_1}
~ ~ ~ ~  \Arg{dimexpr case_2} \Arg{code case_2}
~ ~ ~ ~ \ldots
~ ~ ~ ~ \Arg{dimexpr case_n} \Arg{code case_n}
~ ~ \verb|}|
~ ~ \Arg{true code}
\end{syntax}
This function evaluates the \meta{test dimension expression} and
compares this in turn to each of the
\meta{dimension expression cases}. If the two are equal then the
associated \meta{code} is left in the input stream
and other cases are discarded. If any of the
cases are matched, the \meta{true code} is also inserted into the
input stream (after the code for the appropriate case).
\end{function}

\begin{function}{\DimCaseF}
\begin{syntax}
\cs{DimCaseF} \Arg{test dimension expression}
~ ~ \verb|{|
~ ~ ~ ~ \Arg{dimexpr case_1} \Arg{code case_1}
~ ~ ~ ~  \Arg{dimexpr case_2} \Arg{code case_2}
~ ~ ~ ~ \ldots
~ ~ ~ ~ \Arg{dimexpr case_n} \Arg{code case_n}
~ ~ \verb|}|
~ ~ \Arg{false code}
\end{syntax}
This function evaluates the \meta{test dimension expression} and
compares this in turn to each of the
\meta{dimension expression cases}. If the two are equal then the
associated \meta{code} is left in the input stream
and other cases are discarded. If none of the cases
match then the \meta{false code} is inserted.
For example
\begin{demohigh}
\IgnoreSpacesOn
\DimSet\lTmpaDim{5pt}
\DimCaseF{2\lTmpaDim}{
  {5pt}     {\Result{Small}}
  {4pt+6pt} {\Result{Medium}}
  {-10pt}   {\Result{Negative}}
}{
  \Result{No Match}
}
\IgnoreSpacesOff
\end{demohigh}
\end{function}

\begin{function}{\DimCaseTF}
\begin{syntax}
\cs{DimCaseTF} \Arg{test dimension expression}
~ ~ \verb|{|
~ ~ ~ ~ \Arg{dimexpr case_1} \Arg{code case_1}
~ ~ ~ ~  \Arg{dimexpr case_2} \Arg{code case_2}
~ ~ ~ ~ \ldots
~ ~ ~ ~ \Arg{dimexpr case_n} \Arg{code case_n}
~ ~ \verb|}|
~ ~ \Arg{true code}
~ ~ \Arg{false code}
\end{syntax}
This function evaluates the \meta{test dimension expression} and
compares this in turn to each of the
\meta{dimension expression cases}. If the two are equal then the
associated \meta{code} is left in the input stream
and other cases are discarded. If any of the
cases are matched, the \meta{true code} is also inserted into the
input stream (after the code for the appropriate case), while if none
match then the \meta{false code} is inserted.
%For example
%\begin{demohigh}
%\IgnoreSpacesOn
%\DimSet\lTmpaDim{5pt}
%\DimCaseTF{2\lTmpaDim}{
%  {5pt}     {\Result{Small}}
%  {4pt+6pt} {\Result{Medium}}
%  {-10pt}   {\Result{Negative}}
%}{
%  \Result{[Some Match]}
%}{
%  \Result{[No Match]}
%}
%\IgnoreSpacesOff
%\end{demohigh}
\end{function}

\chapter{Comma Separated Lists (\texttt{Clist})}

\section{Constant and Scratch Comma Lists}

\begin{variable}{\cEmptyClist}
Constant that is always empty.
\end{variable}

\begin{variable}{\lTmpaClist,\lTmpbClist,\lTmpcClist,\lTmpiClist,\lTmpjClist,\lTmpkClist}
Scratch comma lists for local assignment. These are never used by
the \verb!functional! package, and so are safe for use with any
function. However, they may be overwritten by other
code and so should only be used for short-term storage.
\end{variable}

\begin{variable}{\gTmpaClist,\gTmpbClist,\gTmpcClist,\gTmpiClist,\gTmpjClist,\gTmpkClist}
Scratch comma lists for global assignment. These are never used by
the \verb!functional! package, and so are safe for use with any
function. However, they may be overwritten by other
code and so should only be used for short-term storage.
\end{variable}

\section{Creating and Using Comma Lists}

\begin{function}{\ClistNew}
\begin{syntax}
\cs{ClistNew} \meta{comma list}
\end{syntax}
Creates a new \meta{comma list} or raises an error if the name is
already taken. The declaration is global. The \meta{comma list}
initially contains no items.
\end{function}
 
\begin{function}{\ClistConst}
\begin{syntax}
\cs{ClistConst} \meta{clist var} \Arg{comma list}
\end{syntax}
Creates a new constant \meta{clist var} or raises an error
if the name is already taken. The value of the
\meta{clist var} is set globally to the
\meta{comma list}.
\end{function}

\begin{function}{\ClistClear}
\begin{syntax}
\cs{ClistClear} \meta{comma list}
\end{syntax}
Clears all items from the \meta{comma list}.
\end{function}
 
\begin{function}{\ClistClearNew}
\begin{syntax}
\cs{ClistClearNew} \meta{comma list}
\end{syntax}
Ensures that the \meta{comma list} exists globally by applying
\cs{ClistNew} if necessary, then applies \cs{ClistClear} to leave
the list empty.
\end{function}
 
\begin{function}{\ClistSetEq}
\begin{syntax}
\cs{ClistSetEq} \meta{comma list_1} \meta{comma list_2}
\end{syntax}
Sets the content of \meta{comma list_1} equal to that of
\meta{comma list_2}.  To set a token list variable equal to a comma
list variable, use \cs{TlSetEq}.  Conversely, setting a comma
list variable to a token list is unadvisable unless one checks
space-trimming and related issues.
\end{function}
 
\begin{function}{\ClistSetFromSeq}
\begin{syntax}
\cs{ClistSetFromSeq} \meta{comma list} \meta{sequence}
\end{syntax}
Converts the data in the \meta{sequence} into a \meta{comma list}:
the original \meta{sequence} is unchanged.
Items which contain either spaces or commas are surrounded by braces.
\end{function}
 
\begin{function}{\ClistConcat}
\begin{syntax}
\cs{ClistConcat} \meta{comma list_1} \meta{comma list_2} \meta{comma list_3}
\end{syntax}
Concatenates the content of \meta{comma list_2} and \meta{comma list_3}
together and saves the result in \meta{comma list_1}. The items in
\meta{comma list_2} are placed at the left side of the new comma list.
\end{function}

\begin{function}{\ClistCount,\ClistVarCount}
\begin{syntax}
\cs{ClistCount} \Arg{comma list}
\cs{ClistVarCount} \meta{comma list}
\end{syntax}
Returns the number of items in the \meta{comma list}
as an \meta{integer denotation}. The total number of items
in a \meta{comma list} includes those which are duplicates,
\emph{i.e.} every item in a \meta{comma list} is counted.
\end{function}
 
\begin{function}{\ClistVarJoin}
\begin{syntax}
\cs{ClistVarJoin} \meta{clist var} \Arg{separator}
\end{syntax}
Returns the contents of the \meta{clist var},
with the \meta{separator} between the items.
%If the comma list has a single item, it is placed in the input stream,
%and a comma list with no items produces no output.
%An error is raised if the variable does not exist or if it is invalid.
For example,
\begin{demohigh}
\ClistSet \lTmpaClist { a , b , , c , {de} , f }
\ClistVarJoin \lTmpaClist { and }
\end{demohigh}
%\begin{texnote}
%The result is returned within the \tn{unexpanded}
%primitive (\cs{exp_not:n}), which means that the \meta{items}
%do not expand further when appearing in an \texttt{x}-type
%or \texttt{e}-type argument expansion.
%\end{texnote}
\end{function}

\begin{function}{\ClistVarJoinExtended}
\begin{syntax}
\cs{ClistVarJoinExtended} \meta{clist var} \Arg{separator between two} \Arg{separator between more than two} \Arg{separator between final two}
\end{syntax}
Returns the contents of the \meta{clist var},
with the appropriate \meta{separator} between the items. Namely, if
the comma list has more than two items, the \meta{separator between
more than two} is placed between each pair of items except the
last, for which the \meta{separator between final two} is used.  If
the comma list has exactly two items, then they are joined with
the \meta{separator between two} and returns.
%If the comma list has a single item, it is placed in the input stream,
%and a comma list with no items produces no output.
%An error is raised if the variable does not exist or if it is invalid.
For example,
\begin{demohigh}
\ClistSet \lTmpaClist { a , b , , c , {de} , f }
\ClistVarJoinExtended \lTmpaClist { and } {, } {, and }
\end{demohigh}
The first separator argument is not used in this case
because the comma list has more than $2$ items.
%\begin{texnote}
%The result is returned within the \tn{unexpanded}
%primitive (\cs{exp_not:n}), which means that the \meta{items}
%do not expand further when appearing in an \texttt{x}-type
%or \texttt{e}-type argument expansion.
%\end{texnote}
\end{function}

\begin{function}{\ClistJoin,\ClistJoinExtended}
\begin{syntax}
\cs{ClistJoin} \meta{comma list} \Arg{separator}
\cs{ClistJoinExtended} \meta{comma list} \Arg{separator between two} \Arg{separator between more than two} \Arg{separator between final two}
\end{syntax}
Returns the contents of the \meta{comma list},
with the appropriate \meta{separator} between the items. As for
\cs{ClistSet}, blank items are omitted, spaces are removed from
both sides of each item, then a set of braces is removed if the
resulting space-trimmed item is braced.  The \meta{separators} are
then inserted in the same way as for \cs{ClistVarJoin} and
\cs{ClistVarJoinExtended}, respectively.
%\begin{texnote}
%The result is returned within the \tn{unexpanded}
%primitive (\cs{exp_not:n}), which means that the \meta{items}
%do not expand further when appearing in an \texttt{x}-type
%or \texttt{e}-type argument expansion.
%\end{texnote}
\end{function}

\section{Viewing Comma Lists}

\begin{function}{\ClistLog}
\begin{syntax}
\cs{ClistLog} \Arg{tokens}
\end{syntax}
Writes the entries in the comma list in the log file. See also
\cs{ClistShow} which displays the result in the terminal.
\end{function}

\begin{function}{\ClistVarLog}
\begin{syntax}
\cs{ClistVarLog} \meta{comma list}
\end{syntax}
Writes the entries in the \meta{comma list} in the log file. See
also \cs{ClistVarShow} which displays the result in the terminal.
\end{function}

\begin{function}{\ClistShow}
\begin{syntax}
\cs{ClistShow} \Arg{tokens}
\end{syntax}
Displays the entries in the comma list in the terminal.
\end{function}

\begin{function}{\ClistVarShow}
\begin{syntax}
\cs{ClistVarShow} \meta{comma list}
\end{syntax}
Displays the entries in the \meta{comma list} in the terminal.
\end{function}

\section{Adding Data to Comma Lists}
 
\begin{function}{\ClistSet}
\begin{syntax}
\cs{ClistSet} \meta{comma list} \verb|{|\meta{item_1},\ldots{},\meta{item_n}\verb|}|
\end{syntax}
Sets \meta{comma list} to contain the \meta{items},
removing any previous content from the variable.
Blank items are omitted, spaces are removed from both sides of each
item, then a set of braces is removed if the resulting space-trimmed
item is braced.
To store some \meta{tokens} as a single \meta{item} even if the
\meta{tokens} contain commas or spaces, add a set of braces:
\cs{ClistSet} \meta{comma list} \verb|{| \Arg{tokens} \verb|}|.
\end{function}
 
\begin{function}{\ClistPutLeft}
\begin{syntax}
\cs{ClistPutLeft} \meta{comma list} \verb|{|\meta{item_1},\ldots{},\meta{item_n}\verb|}|
\end{syntax}
Appends the \meta{items} to the left of the \meta{comma list}.
Blank items are omitted, spaces are removed from both sides of each
item, then a set of braces is removed if the resulting space-trimmed
item is braced.
To append some \meta{tokens} as a single \meta{item} even if the
\meta{tokens} contain commas or spaces, add a set of braces:
\cs{ClistPutLeft} \meta{comma list} \verb|{| \Arg{tokens} \verb|}|.
\end{function}
 
\begin{function}{\ClistPutRight}
\begin{syntax}
\cs{ClistPutRight} \meta{comma list} \verb|{|\meta{item_1},\ldots{},\meta{item_n}\verb|}|
\end{syntax}
Appends the \meta{items} to the right of the \meta{comma list}.
Blank items are omitted, spaces are removed from both sides of each
item, then a set of braces is removed if the resulting space-trimmed
item is braced.
To append some \meta{tokens} as a single \meta{item} even if the
\meta{tokens} contain commas or spaces, add a set of braces:
\cs{ClistPutRight} \meta{comma list} \verb|{| \Arg{tokens} \verb|}|.
\end{function}
 
\section{Modifying Comma Lists}
 
While comma lists are normally used as ordered lists, it may be
necessary to modify the content. The functions here may be used
to update comma lists, while retaining the order of the unaffected
entries.
 
\begin{function}{\ClistRemoveDuplicates}
\begin{syntax}
\cs{ClistRemoveDuplicates} \meta{comma list}
\end{syntax}
Removes duplicate items from the \meta{comma list}, leaving the
left most copy of each item in the \meta{comma list}.  The \meta{item}
comparison takes place on a token basis, as for \cs{TlIfEqTF}.
\begin{texnote}
This function iterates through every item in the \meta{comma list} and
does a comparison with the \meta{items} already checked. It is therefore
relatively slow with large comma lists.
Furthermore, it may fail if any of the items in the
\meta{comma list} contains \verb|{|, \verb|}|, or \verb|#|
(assuming the usual \TeX{} category codes apply).
\end{texnote}
\end{function}
 
\begin{function}{\ClistRemoveAll}
\begin{syntax}
\cs{ClistRemoveAll} \meta{comma list} \Arg{item}
\end{syntax}
Removes every occurrence of \meta{item} from the \meta{comma list}.
The \meta{item} comparison takes place on a token basis, as for
\cs{TlIfEqTF}.
\begin{texnote}
The function may fail if the \meta{item} contains \verb|{|, \verb|}|, or \verb|#|
(assuming the usual \TeX{} category codes apply).
\end{texnote}
\end{function}
 
\begin{function}{\ClistReverse}
\begin{syntax}
\cs{ClistReverse} \meta{comma list}
\end{syntax}
Reverses the order of items stored in the \meta{comma list}.
\end{function}
 
%\begin{function}{\ClistSort}
%\begin{syntax}
%\cs{ClistSort} \meta{clist var} \Arg{comparison code}
%\end{syntax}
%Sorts the items in the \meta{clist var} according to the
%\meta{comparison code}, and assigns the result to
%\meta{clist var}. The details of sorting comparison are
%described in Section \ref{sec:l3sort:mech}.
%\end{function}

\section{Using a Single Item}

\begin{function}{\ClistItem}
\begin{syntax}
\cs{ClistItem} \Arg{comma list} \Arg{integer expression}
\end{syntax}
Indexing items in the \meta{comma list} from $1$ at the top (left), this
function evaluates the \meta{integer expression} and returns the
appropriate item from the comma list. If the
\meta{integer expression} is negative, indexing occurs from the
bottom (right) of the comma list. When the \meta{integer expression}
is larger than the number of items in the \meta{comma list} (as
calculated by \cs{ClistCount}) then the function returns nothing.
%\begin{texnote}
%The result is returned within the \tn{unexpanded}
%primitive (\cs{exp_not:n}), which means that the \meta{item}
%does not expand further when appearing in an \texttt{x}-type
%or \texttt{e}-type argument expansion.
%\end{texnote}
\end{function}
 
\begin{function}{\ClistVarItem}
\begin{syntax}
\cs{ClistVarItem} \meta{comma list} \Arg{integer expression}
\end{syntax}
Indexing items in the \meta{comma list} from $1$ at the top (left), this
function evaluates the \meta{integer expression} and returns the
appropriate item from the comma list. If the
\meta{integer expression} is negative, indexing occurs from the
bottom (right) of the comma list. When the \meta{integer expression}
is larger than the number of items in the \meta{comma list} (as
calculated by \cs{ClistVarCount}) then the function returns nothing.
%\begin{texnote}
%The result is returned within the \tn{unexpanded}
%primitive (\cs{exp_not:n}), which means that the \meta{item}
%does not expand further when appearing in an \texttt{x}-type
%or \texttt{e}-type argument expansion.
%\end{texnote}
\end{function}
 
\begin{function}{\ClistRandItem,\ClistVarRandItem}
\begin{syntax}
\cs{ClistRandItem} \Arg{comma list}
\cs{ClistVarRandItem} \meta{clist var}
\end{syntax}
Selects a pseudo-random item of the \meta{comma list}.
If the \meta{comma list} has no item, the result is empty.
%\begin{texnote}
%The result is returned within the \tn{unexpanded}
%primitive (\cs{exp_not:n}), which means that the \meta{item}
%does not expand further when appearing in an \texttt{x}-type
%or \texttt{e}-type argument expansion.
%\end{texnote}
\end{function}

\section{Comma Lists as Stacks}
 
Comma lists can be used as stacks, where data is pushed to and popped
from the top of the comma list. (The left of a comma list is the top, for
performance reasons.) The stack functions for comma lists are not
intended to be mixed with the general ordered data functions detailed
in the previous section: a comma list should either be used as an
ordered data type or as a stack, but not in both ways.
 
\begin{function}{\ClistGet,\ClistGetTF}
\begin{syntax}
\cs{ClistGet} \meta{comma list} \meta{token list variable}
\cs{ClistGetT} \meta{comma list} \meta{token list variable} \meta{true code}
\cs{ClistGetF} \meta{comma list} \meta{token list variable} \meta{false code}
\cs{ClistGetTF} \meta{comma list} \meta{token list variable} \meta{true code} \meta{false code}
\end{syntax}
Stores the left-most item from a \meta{comma list} in the
\meta{token list variable} without removing it from the
\meta{comma list}. The \meta{token list variable} is assigned locally.
%In the non-branching version, if the \meta{comma list} is empty the
%\meta{token list variable} is set to the marker value \cs{qNoValue}.
\end{function}
 
\begin{function}{\ClistPop,\ClistPopT,\ClistPopF,\ClistPopTF}
\begin{syntax}
\cs{ClistPop} \meta{comma list} \meta{token list variable}
\cs{ClistPopT} \meta{comma list} \meta{token list variable} \Arg{true code}
\cs{ClistPopF} \meta{comma list} \meta{token list variable} \Arg{false code}
\cs{ClistPopTF} \meta{comma list} \meta{token list variable} \Arg{true code} \Arg{false code}
\end{syntax}
Pops the left-most item from a \meta{comma list} into the
\meta{token list variable}, \emph{i.e.} removes the item from the
comma list and stores it in the \meta{token list variable}.
The assignment of the \meta{token list variable} is local.
If the \meta{comma list} is empty,
the value of the \meta{token list variable} is
not defined in this case and should not be relied upon. 
\end{function}
 
\begin{function}{\ClistPush}
\begin{syntax}
\cs{ClistPush} \meta{comma list} \Arg{items}
\end{syntax}
Adds the \Arg{items} to the top of the \meta{comma list}.
Spaces are removed from both sides of each item as for any
\texttt{n}-type comma list.
\end{function}

\section{Mapping over Comma Lists}
 
%The functions described in this section apply a specified function
%to each item of a comma list.
%All mappings are done at the current group level, \emph{i.e.} any
%local assignments made by the \meta{function} or \meta{code} discussed
%below remain in effect after the loop.
 
When the comma list is given explicitly, %as an \texttt{n}-type argument,
spaces are trimmed around each item.
If the result of trimming spaces is empty, the item is ignored.
Otherwise, if the item is surrounded by braces, one set is removed,
and the result is passed to the mapped function. Thus, if the
comma list that is being mapped is \verb*|{a , {{b} }, ,{}, {c},}|
then the arguments passed to the mapped function are
`\verb*|a|', `\verb*|{b} |', an empty argument, and `\verb*|c|'.
 
When the comma list is given as a variable, spaces
have already been trimmed on input, and items are simply stripped
of one set of braces if any. This case is more efficient than using
explicit comma lists.

%\begin{function}{\ClistMapFunction,\ClistVarMapFunction}
%\begin{syntax}
%\cs{ClistMapFunction} \Arg{comma list} \meta{function}
%\cs{ClistVarMapFunction} \meta{comma list} \meta{function}
%\end{syntax}
%Applies \meta{function} to every \meta{item} stored in the
%\meta{comma list}. The \meta{function} receives one argument for
%each iteration. The \meta{items} are returned from left to right.
%The function \cs{ClistMapInline} is in general more efficient
%than \cs{ClistMapFunction}.
%\end{function}
% 
%\begin{function}{\ClistMapInline,\ClistVarMapInline}
%\begin{syntax}
%\cs{ClistMapInline} \Arg{comma list} \Arg{inline function}
%\cs{ClistVarMapInline} \meta{comma list} \Arg{inline function}
%\end{syntax}
%Applies \meta{inline function} to every \meta{item} stored
%within the \meta{comma list}. The \meta{inline function} should
%consist of code which receives the \meta{item} as \verb|#1|.
%The \meta{items} are returned from left to right.
%\end{function}

\begin{function}{\ClistMapVariable,\ClistVarMapVariable}
\begin{syntax}
\cs{ClistMapVariable} \Arg{comma list} \meta{variable} \Arg{code}
\cs{ClistVarMapVariable} \meta{comma list} \meta{variable} \Arg{code}
\end{syntax}
Stores each \meta{item} of the \meta{comma list} in turn in the
(token list) \meta{variable} and applies the \meta{code}.  The
\meta{code} will usually make use of the \meta{variable}, but this
is not enforced.  The assignments to the \meta{variable} are local.
Its value after the loop is the last \meta{item} in the \meta{comma
list}, or its original value if there were no \meta{item}.  The
\meta{items} are returned from left to right.
\end{function}
 
%\begin{function}{\ClistMapTokens,\ClistVarMapTokens}
%\begin{syntax}
%\cs{ClistMapTokens} \Arg{comma list} \Arg{code}
%\cs{ClistVarMapTokens} \meta{clist var} \Arg{code}
%\end{syntax}
%Calls \meta{code} \Arg{item} for every \meta{item} stored in the
%\meta{comma list}. The \meta{code} receives each \meta{item} as a
%trailing brace group.  If the \meta{code} consists of a single
%function this is equivalent to \cs{ClistMapFunction} or \cs{ClistVarMapFunction}.
%\end{function}
 
%\begin{function}{\ClistMapBreak}
%\begin{syntax}
%\cs{ClistMapBreak}
%\end{syntax}
%Used to terminate a clist map function before all
%entries in the \meta{comma list} have been processed. This
%normally takes place within a conditional statement, for example
%\begin{verbatim}
%\clist_map_inline:Nn \l_my_clist
%{
%\str_if_eq:nnTF { #1 } { bingo }
%{ \clist_map_break: }
%{
%Do something useful
%}
%}
%\end{verbatim}
%Use outside of a clist map scenario leads to low
%level \TeX{} errors.
%\begin{texnote}
%When the mapping is broken, additional tokens may be inserted
%before further items are taken
%from the input stream. This depends on the design of the mapping
%function.
%\end{texnote}
%\end{function}
% 
%\begin{function}{\ClistMapBreakDo}
%\begin{syntax}
%\cs{ClistMapBreakDo} \Arg{code}
%\end{syntax}
%Used to terminate a clist map  function before all
%entries in the \meta{comma list} have been processed, inserting
%the \meta{code} after the mapping has ended. This
%normally takes place within a conditional statement, for example
%\begin{verbatim}
%\clist_map_inline:Nn \l_my_clist
%{
%\str_if_eq:nnTF { #1 } { bingo }
%{ \clist_map_break:n { <code> } }
%{
%Do something useful
%}
%}
%\end{verbatim}
%Use outside of a clist map scenario leads to low
%level \TeX{} errors.
%\begin{texnote}
%When the mapping is broken, additional tokens may be inserted
%before the \meta{code} is
%inserted into the input stream.
%This depends on the design of the mapping function.
%\end{texnote}
%\end{function}

\section{Comma List Conditionals}

\begin{function}{\ClistIfExist,\ClistIfExistTF}
\begin{syntax}
\cs{ClistIfExist} \meta{comma list}
\cs{ClistIfExistTF} \meta{comma list} \Arg{true code} \Arg{false code}
\end{syntax}
Tests whether the \meta{comma list} is currently defined.  This does
not check that the \meta{comma list} really is a comma list.
\end{function}

\begin{function}{\ClistIfEmpty,\ClistIfEmptyTF}
\begin{syntax}
\cs{ClistIfEmpty} \Arg{comma list}
\cs{ClistIfEmptyTF} \Arg{comma list} \Arg{true code} \Arg{false code}
\end{syntax}
Tests if the \meta{comma list} is empty (containing no items).
The rules for space trimming are as for other \texttt{n}-type
comma-list functions, hence the comma list \verb|{ , ,, }| (without
outer braces) is empty, while \verb|{ ,{},}| (without outer braces)
contains one element, which happens to be empty: the comma-list
is not empty.
\end{function}

\begin{function}{\ClistVarIfEmpty,\ClistVarIfEmptyTF}
\begin{syntax}
\cs{ClistVarIfEmpty} \meta{comma list}
\cs{ClistVarIfEmptyTF} \meta{comma list} \Arg{true code} \Arg{false code}
\end{syntax}
Tests if the \meta{comma list} is empty (containing no items).
\end{function}
 
\begin{function}{\ClistIfIn,\ClistIfInTF}
\begin{syntax}
\cs{ClistIfIn} \Arg{comma list} \Arg{item}
\cs{ClistIfInTF} \Arg{comma list} \Arg{item} \Arg{true code} \Arg{false code}
\end{syntax}
Tests if the \meta{item} is present in the \meta{comma list}.
In the case of an \texttt{n}-type \meta{comma list}, the usual rules
of space trimming and brace stripping apply. For example
\begin{demohigh}
\ClistIfInTF { a , {b}  , {b} , c } {b} {Yes} {No}
\end{demohigh}
%\begin{texnote}
%The function may fail if the \meta{item} contains \verb|{|, \verb|}|, or \verb|#|
%(assuming the usual \TeX{} category codes apply).
%\end{texnote}
\end{function}

\begin{function}{\ClistVarIfIn,\ClistVarIfInTF}
\begin{syntax}
\cs{ClistVarIfIn} \meta{comma list} \Arg{item}
\cs{ClistVarIfInTF} \meta{comma list} \Arg{item} \Arg{true code} \Arg{false code}
\end{syntax}
Tests if the \meta{item} is present in the \meta{comma list}.
In the case of an \texttt{n}-type \meta{comma list}, the usual rules
of space trimming and brace stripping apply.
%\begin{texnote}
%The function may fail if the \meta{item} contains \verb|{|, \verb|}|, or \verb|#|
%(assuming the usual \TeX{} category codes apply).
%\end{texnote}
\end{function}

\chapter{The Source Code}

%\CodeHigh{lite}
\setlength\parskip{0pt}
\dochighinput[language=latex/latex3]{functional.sty}

\end{document}
