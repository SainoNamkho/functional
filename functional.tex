%  -*- coding: utf-8 -*-

\documentclass[oneside]{book}
\usepackage[a4paper,margin=2.5cm]{geometry}

\setlength{\parindent}{0pt}
\setlength{\parskip}{4pt plus 1pt minus 1pt}

\usepackage{codehigh}

\colorlet{highback}{azure9}
\CodeHigh{language=latex/latex2,style/main=highback,style/code=highback,lite}
\NewCodeHighEnv{code}{style/main=gray9,style/code=gray9}
\NewCodeHighEnv{demo}{style/main=gray9,style/code=gray9,demo}

\let\_=_
\catcode`\_=\active
\def_#1{$\_#1$}%

\ExplSyntaxOn
\NewDocumentCommand\PrintVarList{m}{
  \clist_set:Nn \l_tmpa_clist {#1}
  \clist_map_inline:Nn \l_tmpa_clist
    {
      \token_to_str:N ##1 ~
    }
}
\ExplSyntaxOff

\NewDocumentEnvironment{variable}{m}{
  \vspace{5pt}
  \begin{minipage}{\linewidth}
  \hrule\vspace{4pt}\obeylines%
  \begingroup
  \ttfamily\bfseries\color{olive3}
  \PrintVarList{#1}
  \endgroup
  \par\vspace{4pt}\hrule
  \end{minipage}\par\nopagebreak\vspace{4pt}
}{%
  \vspace{5pt}%
}

\NewDocumentEnvironment{function}{m}{
  \vspace{5pt}%
}{\vspace{5pt}}

\NewDocumentEnvironment{syntax}{}{%
  \begin{minipage}{\linewidth}
  \hrule\vspace{4pt}\obeylines%
}{%
  \par\vspace{4pt}\hrule
  \end{minipage}\par\nopagebreak\vspace{4pt}
}

\NewDocumentEnvironment{texnote}{}{}{}

\NewDocumentCommand\cs{m}{\texttt{\bfseries\color{purple3}\expandafter\string\csname#1\endcsname}}
\NewDocumentCommand\meta{m}{\textsl{$\langle$\ignorespaces#1\unskip$\rangle$}}
\NewDocumentCommand\Arg{m}{\texttt{\{}\textsl{$\langle$\ignorespaces#1\unskip$\rangle$}\texttt{\}}}

\let\tn=\cs

\usepackage{hyperref}
\hypersetup{
  colorlinks=true,
  urlcolor=blue3,
  linkcolor=blue3,
}

\usepackage{functional}

\Functional{scoping=false,tracing=true}

\begin{document}

\chapter{Overview of Features}

\ExplSyntaxOn

\PrgNewFunction \MathSquare { m }
  {
    \IntSet \lTmpaInt { \IntEval { #1 * #1 } }
    \Result { \IntUse \lTmpaInt }
  }

\PrgNewFunction \MathCubic { m }
  {
    \IntSet \lTmpaInt { \IntEval { #1 * #1 * #1 } }
    \Result { \Value \lTmpaInt }
  }

\PrgNewFunction \Factorial { m }
  {
    \IntCompareTF { #1 } = { 0 }
      { \Result { 1 } }
      {
        \TlSet \lTmpaTl
          {
            \IntMathMult { #1 } { \Factorial { \IntMathSub{#1}{1} } }
          }
        \Result { \Value \lTmpaTl }
      }
  }

\ExplSyntaxOff

\MathSquare{5}
\MathSquare{\MathSquare{5}}

\MathCubic{2}
\MathCubic{\MathCubic{2}}

\Factorial{0}
\Factorial{4}

\chapter{Basic Definitions (\texttt{l3basics})}

\GobbleOne{abc} \UseOne{uvw}
\UseGobble{abc}{uvw} \GobbleUse{abc}{uvw}

\chapter{Control Structures (\texttt{l3prg})}

\section{Scratch Variables of Booleans}

\begin{variable}{\lTmpaBool,\lTmpbBool,\lTmpcBool,\lTmpiBool,\lTmpjBool,\lTmpkBool}
Scratch booleans for local assignment. These are never used by
the \verb!functional! package, and so are safe for use with any
function. However, they may be overwritten by other
code and so should only be used for short-term storage.
\end{variable}

\begin{variable}{\gTmpaBool,\gTmpbBool,\gTmpcBool,\gTmpiBool,\gTmpjBool,\gTmpkBool}
Scratch booleans for global assignment. These are never used by
the \verb!functional! package, and so are safe for use with any
function. However, they may be overwritten by other
code and so should only be used for short-term storage.
\end{variable}

%\BoolIfTF\cTrueBool{\Result{true}}{\Result{false}}
%\BoolIfTF\cFalseBool{\Result{true}}{\Result{false}}

\section{Public Functions for Booleans}

\begin{function}{\BoolNew}
\begin{syntax}
\cs{BoolNew} \meta{boolean}
\end{syntax}
Creates a new \meta{boolean} or raises an error if the
name is already taken. The declaration is global. The
\meta{boolean} is initially \texttt{false}.
\end{function}

\begin{function}{\BoolSetTrue}
\begin{syntax}
\cs{BoolSetTrue} \meta{boolean}
\end{syntax}
Sets \meta{boolean} logically \texttt{true}.
\end{function}

\begin{function}{\BoolSetFalse}
\begin{syntax}
\cs{BoolSetFalse} \meta{boolean}
\end{syntax}
Sets \meta{boolean} logically \texttt{false}.
\end{function}

\begin{function}{\BoolIf,\BoolIfTF}
\begin{syntax}
\cs{BoolIf} \meta{boolean}
\cs{BoolIfTF} \meta{boolean} \Arg{true code} \Arg{false code}
\end{syntax}
Tests the current truth of \meta{boolean}, and continues evaluation
based on this result. For example
\begin{demo}
\BoolSetTrue\lTmpaBool
\BoolIfTF\lTmpaBool{\Result{True!}}{\Result{False!}}
\BoolSetFalse\lTmpaBool
\BoolIfTF\lTmpaBool{\Result{True!}}{\Result{False!}}
\end{demo}
\end{function}

\chapter{Token Lists (\texttt{l3tl})}

\section{Scratch Variables of Token Lists}

\begin{variable}{\lTmpaTl,\lTmpbTl,\lTmpcTl,\lTmpiTl,\lTmpjTl,\lTmpkTl}
Scratch token lists for local assignment. These are never used by
the \verb!functional! package, and so are safe for use with any
function. However, they may be overwritten by other
code and so should only be used for short-term storage.
\end{variable}

\begin{variable}{\gTmpaTl,\gTmpbTl,\gTmpcTl,\gTmpiTl,\gTmpjTl,\gTmpkTl}
Scratch token lists for global assignment. These are never used by
the \verb!functional! package, and so are safe for use with any
function. However, they may be overwritten by other
code and so should only be used for short-term storage.
\end{variable}

\section{Public Functions for Token Lists}

\begin{function}{\TlNew}
\begin{syntax}
\cs{TlNew} \meta{tl~var}
\end{syntax}
Creates a new \meta{tl~var} or raises an error if the
name is already taken. The declaration is global. The
\meta{tl~var} is initially empty.
\end{function}

\begin{function}{\TlUse}
\begin{syntax}
\cs{TlUse} \meta{tl~var}
\end{syntax}
Recovers the content of a \meta{tl~var} and return the value.
An error is raised if the variable
does not exist or if it is invalid. Note that it is possible to use
a \meta{tl~var} directly without an accessor function.
\end{function}

\begin{function}{\TlSet}
\begin{syntax}
\cs{TlSet} \meta{tl~var} \Arg{tokens}
\end{syntax}
Sets \meta{tl~var} to contain \meta{tokens},
removing any previous content from the variable. For example
\begin{demo}
\TlSet\lTmpiTl{\IntMathMult{4}{5}}
\TlUse\lTmpiTl
\end{demo}
\end{function}

\begin{function}{\TlClear}
\begin{syntax}
\cs{TlClear} \meta{tl~var}
\end{syntax}
Clears all entries from the \meta{tl~var}. For example
\begin{demo}
\TlSet\lTmpjTl{One}
\TlClear\lTmpjTl
\TlSet\lTmpjTl{Two}
\TlUse\lTmpjTl
\end{demo}
\end{function}

\begin{function}{\TlPutLeft}
\begin{syntax}
\cs{TlPutLeft} \meta{tl~var} \Arg{tokens}
\end{syntax}
Appends \meta{tokens} to the left side of the current content of
\meta{tl~var}. For example
\begin{demo}
\TlSet\lTmpkTl{Functional}
\TlPutLeft\lTmpkTl{Hello}
\TlUse\lTmpkTl
\end{demo}
\end{function}

\begin{function}{\TlPutRight}
\begin{syntax}
\cs{TlPutRight} \meta{tl~var} \Arg{tokens}
\end{syntax}
Appends \meta{tokens} to the right side of the current content of
\meta{tl~var}. For example
\begin{demo}
\TlSet\lTmpkTl{Functional}
\TlPutRight\lTmpkTl{World}
\TlUse\lTmpkTl
\end{demo}
\end{function}

\begin{function}{\TlIfEmpty,\TlIfEmptyTF}
\begin{syntax}
\cs{TlIfEmpty} \meta{tl~var}
\cs{TlIfEmptyTF} \meta{tl~var} \Arg{true code} \Arg{false code}
\end{syntax}
Tests if the \meta{token list variable} is entirely empty
(\emph{i.e.}~contains no tokens at all). For example
\begin{demo}
\TlSet\lTmpaTl{abc}
\TlIfEmptyTF\lTmpaTl{\Result{Empty}}{\Result{NonEmpty}}
\TlClear\lTmpaTl
\TlIfEmptyTF\lTmpaTl{\Result{Empty}}{\Result{NonEmpty}}
\end{demo}
\end{function}

\begin{function}{\TlIfEq,\TlIfEqTF}
\begin{syntax}
\cs{TlIfEq} \meta{tl~var_1} \meta{tl~var_2}
\cs{TlIfEqTF} \meta{tl~var_1} \meta{tl~var_2} \Arg{true code} \Arg{false code}
\end{syntax}
Compares the content of two \meta{token list variables} and
is logically \texttt{true} if the two contain the same list of
tokens (\emph{i.e.}~identical in both the list of characters they
contain and the category codes of those characters). For example
\begin{demo}
\TlSet\lTmpaTl{abc}
\TlSet\lTmpbTl{abc}
\TlSet\lTmpcTl{xyz}
\TlIfEqTF\lTmpaTl\lTmpbTl{\Result{Yes}}{\Result{No}}
\TlIfEqTF\lTmpaTl\lTmpcTl{\Result{Yes}}{\Result{No}}
\end{demo}
%See also \cs{StrIfEqTF} for a comparison that ignores category codes.
\end{function}

\chapter{Integers (\texttt{l3int})}

\section{Scratch Variables of Integers}

\begin{variable}{\lTmpaInt,\lTmpbInt,\lTmpcInt,\lTmpiInt,\lTmpjInt,\lTmpkInt}
Scratch integer for local assignment. These are never used by
the \verb!functional! package, and so are safe for use with any
function. However, they may be overwritten by other
code and so should only be used for short-term storage.
\end{variable}

\begin{variable}{\gTmpaInt,\gTmpbInt,\gTmpcInt,\gTmpiInt,\gTmpjInt,\gTmpkInt}
Scratch integer for global assignment. These are never used by
the \verb!functional! package, and so are safe for use with any
function. However, they may be overwritten by other
code and so should only be used for short-term storage.
\end{variable}

\section{Public Functions for Integers}

\begin{function}{\IntEval}
\begin{syntax}
\cs{IntEval} \Arg{integer expression}
\end{syntax}
Evaluates the \meta{integer expression} and returns the result:
for positive results an
explicit sequence of decimal digits not starting with~\texttt{0},
for negative results \texttt{-}~followed by such a sequence, and
\texttt{0}~for zero. For example
\begin{demo}
\IntEval{(1+4)*(2-3)/5}
\end{demo}
\end{function}

\begin{function}{\IntMathAdd}
\begin{syntax}
\cs{IntMathAdd} \Arg{integer expression_1} \Arg{integer expression_2}
\end{syntax}
Adds \Arg{integer expression_1} and \Arg{integer expression_2},
and returns the result. For example
\begin{demo}
\IntMathAdd{7}{3}
\end{demo}
\end{function}

\begin{function}{\IntMathSub}
\begin{syntax}
\cs{IntMathSub} \Arg{integer expression_1} \Arg{integer expression_2}
\end{syntax}
Subtracts \Arg{integer expression_1} from \Arg{integer expression_2},
and returns the result. For example
\begin{demo}
\IntMathSub{7}{3}
\end{demo}
\end{function}

\begin{function}{\IntMathMult}
\begin{syntax}
\cs{IntMathMult} \Arg{integer expression_1} \Arg{integer expression_2}
\end{syntax}
Multiplies \Arg{integer expression_1} by \Arg{integer expression_2},
and returns the result. For example
\begin{demo}
\IntMathMult{7}{3}
\end{demo}
\end{function}

\begin{function}{\IntMathDiv}
\begin{syntax}
\cs{IntMathDiv} \Arg{integer expression_1} \Arg{integer expression_2}
\end{syntax}
Divides \Arg{integer expression_1} by \Arg{integer expression_2},
and returns the result. For example
\begin{demo}
\IntMathDiv{7}{3}
\end{demo}
\end{function}

\begin{function}{\IntNew}
\begin{syntax}
\cs{IntNew} \meta{integer}
\end{syntax}
Creates a new \meta{integer} or raises an error if the name is
already taken. The declaration is global. The \meta{integer} is
initially equal to $0$.
\end{function}

\begin{function}{\IntUse}
\begin{syntax}
\cs{IntUse} \meta{integer}
\end{syntax}
Recovers the content of an \meta{integer} and return the value.
An error is raised if the variable does
not exist or if it is invalid. Can be omitted in places where an
\meta{integer} is required (such as in the first and third arguments
of \cs{IntCompareTF}).%
%\begin{texnote}
%\cs{IntUse} is the \TeX{} primitive \tn{the}: this is one of
%several \verb!functional! names for this primitive.
%\end{texnote}
\end{function}

\begin{function}{\IntSet}
\begin{syntax}
\cs{IntSet} \meta{integer} \Arg{integer expression}
\end{syntax}
Sets \meta{integer} to the value of \meta{integer expression},
which must evaluate to an integer (as described for \cs{IntEval}).
For example
\begin{demo}
\IntSet\lTmpaInt{3+5}
\IntUse\lTmpaInt
\end{demo}
\end{function}

\begin{function}{\IntZero}
\begin{syntax}
\cs{IntZero} \meta{integer}
\end{syntax}
Sets \meta{integer} to $0$. For example
\begin{demo}
\IntSet\lTmpaInt{5}
\IntZero\lTmpaInt
\IntUse\lTmpaInt
\end{demo}
\end{function}

\begin{function}{\IntIncr}
\begin{syntax}
\cs{IntIncr} \meta{integer}
\end{syntax}
Increases the value stored in \meta{integer} by $1$.
For example
\begin{demo}
\IntSet\lTmpaInt{5}
\IntIncr\lTmpaInt
\IntUse\lTmpaInt
\end{demo}
\end{function}

\begin{function}{\IntDecr}
\begin{syntax}
\cs{IntDecr} \meta{integer}
\end{syntax}
Decreases the value stored in \meta{integer} by $1$.
For example
\begin{demo}
\IntSet\lTmpaInt{5}
\IntDecr\lTmpaInt
\IntUse\lTmpaInt
\end{demo}
\end{function}

\begin{function}{\IntAdd}
\begin{syntax}
\cs{IntAdd} \meta{integer} \Arg{integer expression}
\end{syntax}
Adds the result of the \meta{integer expression} to the current
content of the \meta{integer}. For example
\begin{demo}
\IntSet\lTmpaInt{5}
\IntAdd\lTmpaInt{2}
\IntUse\lTmpaInt
\end{demo}
\end{function}

\begin{function}{\IntSub}
\begin{syntax}
\cs{IntSub} \meta{integer} \Arg{integer expression}
\end{syntax}
Subtracts the result of the \meta{integer expression} from the
current content of the \meta{integer}. For example
\begin{demo}
\IntSet\lTmpaInt{5}
\IntSub\lTmpaInt{3}
\IntUse\lTmpaInt
\end{demo}
\end{function}

\begin{function}{\IntStepVariable}
\begin{syntax}
\cs{IntStepVariable} \Arg{initial value} \Arg{step} \Arg{final value} \meta{tl~var} \Arg{code}
\end{syntax}
This function first evaluates the \meta{initial value}, \meta{step}
and \meta{final value}, all of which should be integer expressions.
Then for each \meta{value} from the \meta{initial value} to the
\meta{final value} in turn (using \meta{step} between each
\meta{value}), the \meta{code} is evaluated,
with the \meta{tl~var} defined as the current \meta{value}.  Thus
the \meta{code} should make use of the \meta{tl~var}.
For example
\begin{demo}
\TlClear\lTmpaTl
\IntStepVariable{1}{3}{30}\lTmpiTl{
  \TlPutRight\lTmpaTl{\Value\lTmpiTl}
  \TlPutRight\lTmpaTl{ }
}
\Result{\Value\lTmpaTl}
\end{demo}
\end{function}

\begin{function}{\IntCompare,\IntCompareTF}
\begin{syntax}
\cs{IntCompare} \Arg{intexpr_1} \meta{relation} \Arg{intexpr_2}
\cs{IntCompareTF} \Arg{intexpr_1} \meta{relation} \Arg{intexpr_2} \Arg{true code} \Arg{false code}
\end{syntax}
This function first evaluates each of the \meta{integer expressions}
as described for \cs{IntEval}. The two results are then
compared using the \meta{relation}:\par
{\centering\begin{tabular}{ll}
Equal        & \texttt{=} \\
Greater than & \texttt{>} \\
Less than    & \texttt{<} \\
\end{tabular}\par}
For example
\begin{demo}
\IntCompareTF{2}>{1}{\Result{Greater}}{\Result{Less}}
\IntCompareTF{2}>{3}{\Result{Greater}}{\Result{Less}}
\end{demo}
\end{function}

\end{document}

