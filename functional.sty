%%% -*- coding: utf-8 -*-
%% ----------------------------------------------------------------------------
%% Functional: LaTeX2 functional interfaces for LaTeX3 programming layer
%% Copyright : 2022 (c) Jianrui Lyu <tolvjr@163.com>
%% Repository: https://github.com/lvjr/functional
%% Repository: https://bitbucket.org/lvjr/functional
%% License   : The LaTeX Project Public License 1.3c
%% ----------------------------------------------------------------------------

%%% --------------------------------------------------------
%%> \section{Interfaces for Functional Programming (Prg)}
%%% --------------------------------------------------------

\NeedsTeXFormat{LaTeX2e}[2018-04-01]

\RequirePackage{expl3}
\ProvidesExplPackage{functional}{2022-04-15}{2022D}
  {^^JLaTeX2 functional interfaces for LaTeX3 programming layer}

\cs_generate_variant:Nn \iow_log:n { V }
\cs_generate_variant:Nn \str_set:Nn { Ne }
\cs_generate_variant:Nn \tl_log:n { e }
\cs_generate_variant:Nn \tl_set:Nn { Ne }

\prg_generate_conditional_variant:Nnn \str_if_eq:nn { Ve } { TF }

\tl_new:N \gResultTl
\int_new:N \l__fun_arg_count_int
\tl_new:N \l__fun_parameters_defined_tl
\tl_const:Nn \c__fun_parameter_defined_i__tl     {  } % no argument
\tl_const:Nn \c__fun_parameter_defined_i_i_tl    { #1 }
\tl_const:Nn \c__fun_parameter_defined_i_ii_tl   { #1 #2 }
\tl_const:Nn \c__fun_parameter_defined_i_iii_tl  { #1 #2 #3 }
\tl_const:Nn \c__fun_parameter_defined_i_iv_tl   { #1 #2 #3 #4 }
\tl_const:Nn \c__fun_parameter_defined_i_v_tl    { #1 #2 #3 #4 #5 }
\tl_const:Nn \c__fun_parameter_defined_i_vi_tl   { #1 #2 #3 #4 #5 #6 }
\tl_const:Nn \c__fun_parameter_defined_i_vii_tl  { #1 #2 #3 #4 #5 #6 #7 }
\tl_const:Nn \c__fun_parameter_defined_i_viii_tl { #1 #2 #3 #4 #5 #6 #7 #8 }
\tl_const:Nn \c__fun_parameter_defined_i_ix_tl   { #1 #2 #3 #4 #5 #6 #7 #8 #9 }
\tl_new:N \l__fun_parameters_called_tl
\tl_const:Nn \c__fun_parameter_called_i_i_tl   { {#1} }
\tl_const:Nn \c__fun_parameter_called_i_ii_tl  { {#1}{#2} }
\tl_const:Nn \c__fun_parameter_called_i_iii_tl { {#1}{#2}{#3} }
\tl_const:Nn \c__fun_parameter_called_i_iv_tl  { {#1}{#2}{#3}{#4} }
\tl_const:Nn \c__fun_parameter_called_i_v_tl   { {#1}{#2}{#3}{#4}{#5} }
\tl_const:Nn \c__fun_parameter_called_i_vi_tl  { {#1}{#2}{#3}{#4}{#5}{#6} }
\tl_const:Nn \c__fun_parameter_called_i_vii_tl { {#1}{#2}{#3}{#4}{#5}{#6}{#7} }
\tl_new:N \l__fun_parameters_true_tl
\tl_new:N \l__fun_parameters_false_tl
\tl_const:Nn \c__fun_parameter_called_i_tl    { {#1} }
\tl_const:Nn \c__fun_parameter_called_ii_tl   { {#2} }
\tl_const:Nn \c__fun_parameter_called_iii_tl  { {#3} }
\tl_const:Nn \c__fun_parameter_called_iv_tl   { {#4} }
\tl_const:Nn \c__fun_parameter_called_v_tl    { {#5} }
\tl_const:Nn \c__fun_parameter_called_vi_tl   { {#6} }
\tl_const:Nn \c__fun_parameter_called_vii_tl  { {#7} }
\tl_const:Nn \c__fun_parameter_called_viii_tl { {#8} }
\tl_const:Nn \c__fun_parameter_called_ix_tl   { {#9} }

%% #1: function name; #2: argument specification; #3 function body
\cs_new_protected:Npn \__fun_new_function:Nnn #1 #2 #3
  {
    \int_set:Nn \l__fun_arg_count_int { \tl_count:n {#2} } % spaces are ignored
    \tl_set_eq:Nc \l__fun_parameters_defined_tl
      { c__fun_parameter_defined_i_ \int_to_roman:n { \l__fun_arg_count_int } _tl }
    \exp_last_unbraced:NcV \cs_new_protected:Npn
      { __fun_defined_ \cs_to_str:N #1 : w }
      \l__fun_parameters_defined_tl
      {
        \__fun_group_begin:
        \tl_gclear:N \gResultTl
        #3
        \__fun_tracing_log:e { [O] ~ \exp_not:V \gResultTl }
        \__fun_group_end:
      }
    \use:c { __fun_new_with_arg_ \int_to_roman:n { \l__fun_arg_count_int } :NnV }
      #1 {#2} \l__fun_parameters_defined_tl
  }
\cs_generate_variant:Nn \__fun_new_function:Nnn { cne }

\cs_set_eq:NN \PrgNewFunction \__fun_new_function:Nnn

\tl_new:N \g__fun_last_result_tl
\int_new:N \l__fun_cond_arg_count_int

%% #1: function name; #2: argument specification; #3 function body
\cs_new_protected:Npn \__fun_new_conditional:Nnn #1 #2 #3
  {
    \__fun_new_function:Nnn #1 { #2 } { #3 }
    \int_set:Nn \l__fun_cond_arg_count_int { \tl_count:n {#2} }
    \tl_set_eq:Nc \l__fun_parameters_called_tl
      {
        c__fun_parameter_called_i_
        \int_to_roman:n { \l__fun_cond_arg_count_int } _tl
      }
    %% define function \FooIfBarT for #1=\FooIfBar
    \tl_set_eq:Nc \l__fun_parameters_true_tl
      {
        c__fun_parameter_called_
        \int_to_roman:n { \l__fun_cond_arg_count_int + 1 } _tl
      }
    \__fun_new_function:cne { \cs_to_str:N #1 T } { #2 n }
      {
        #1 \exp_not:V \l__fun_parameters_called_tl
        \exp_not:n
          {
            \tl_set_eq:NN \g__fun_last_result_tl \gResultTl
            \tl_gclear:N \gResultTl
            \exp_last_unbraced:NV \bool_if:NT \g__fun_last_result_tl
          }
        \exp_not:V \l__fun_parameters_true_tl
      }
    %% define function \FooIfBarF for #1=\FooIfBar
    \tl_set_eq:Nc \l__fun_parameters_false_tl
      {
        c__fun_parameter_called_
        \int_to_roman:n { \l__fun_cond_arg_count_int + 1 } _tl
      }
    \__fun_new_function:cne { \cs_to_str:N #1 F } { #2 n }
      {
        #1 \exp_not:V \l__fun_parameters_called_tl
        \exp_not:n
          {
            \tl_set_eq:NN \g__fun_last_result_tl \gResultTl
            \tl_gclear:N \gResultTl
            \exp_last_unbraced:NV \bool_if:NF \g__fun_last_result_tl
          }
        \exp_not:V \l__fun_parameters_false_tl
      }
    %% define function \FooIfBarTF for #1=\FooIfBar
    \tl_set_eq:Nc \l__fun_parameters_true_tl
      {
        c__fun_parameter_called_
        \int_to_roman:n { \l__fun_cond_arg_count_int + 1 } _tl
      }
    \tl_set_eq:Nc \l__fun_parameters_false_tl
      {
        c__fun_parameter_called_
        \int_to_roman:n { \l__fun_cond_arg_count_int + 2 } _tl
      }
    \__fun_new_function:cne { \cs_to_str:N #1 TF } { #2 n n }
      {
        #1 \exp_not:V \l__fun_parameters_called_tl
        \exp_not:n
          {
            \tl_set_eq:NN \g__fun_last_result_tl \gResultTl
            \tl_gclear:N \gResultTl
            \exp_last_unbraced:NV \bool_if:NTF \g__fun_last_result_tl
          }
        \exp_not:V \l__fun_parameters_true_tl
        \exp_not:V \l__fun_parameters_false_tl
      }
  }

\cs_set_eq:NN \PrgNewConditional \__fun_new_conditional:Nnn

\int_new:N \g__fun_nesting_level_int

%% #1: function name; #2: argument specifications; #3 parameters tl defined
%% Some times we need to create a function without arguments
\cs_new_protected:Npn \__fun_new_with_arg_:Nnn #1 #2 #3
  {
    \cs_new_protected:Npn #1 #3
      {
        \int_gincr:N \g__fun_nesting_level_int
        \__fun_evaluate:Nn #1 {#2}
        \int_gdecr:N \g__fun_nesting_level_int
        \__fun_return_result:
      }
  }
\cs_generate_variant:Nn \__fun_new_with_arg_:Nnn { NnV }

%% #1: function name; #2: argument specifications; #3 parameters tl defined
\cs_new_protected:Npn \__fun_new_with_arg_i:Nnn #1 #2 #3
  {
    \cs_new_protected:Npn #1 #3
      {
        \int_gincr:N \g__fun_nesting_level_int
        \__fun_one_argument_gset:nn { 1 } { ##1 }
        \__fun_evaluate:Nn #1 {#2}
        \int_gdecr:N \g__fun_nesting_level_int
        \__fun_return_result:
      }
  }
\cs_generate_variant:Nn \__fun_new_with_arg_i:Nnn { NnV }

%% #1: function name; #2: argument specifications; #3 parameters tl defined
\cs_new_protected:Npn \__fun_new_with_arg_ii:Nnn #1 #2 #3
  {
    \cs_new_protected:Npn #1 #3
      {
        \int_gincr:N \g__fun_nesting_level_int
        \__fun_one_argument_gset:nn { 1 } { ##1 }
        \__fun_one_argument_gset:nn { 2 } { ##2 }
        \__fun_evaluate:Nn #1 {#2}
        \int_gdecr:N \g__fun_nesting_level_int
        \__fun_return_result:
      }
  }
\cs_generate_variant:Nn \__fun_new_with_arg_ii:Nnn { NnV }

%% #1: function name; #2: argument specifications; #3 parameters tl defined
\cs_new_protected:Npn \__fun_new_with_arg_iii:Nnn #1 #2 #3
  {
    \cs_new_protected:Npn #1 #3
      {
        \int_gincr:N \g__fun_nesting_level_int
        \__fun_one_argument_gset:nn { 1 } { ##1 }
        \__fun_one_argument_gset:nn { 2 } { ##2 }
        \__fun_one_argument_gset:nn { 3 } { ##3 }
        \__fun_evaluate:Nn #1 {#2}
        \int_gdecr:N \g__fun_nesting_level_int
        \__fun_return_result:
      }
  }
\cs_generate_variant:Nn \__fun_new_with_arg_iii:Nnn { NnV }

%% #1: function name; #2: argument specifications; #3 parameters tl defined
\cs_new_protected:Npn \__fun_new_with_arg_iv:Nnn #1 #2 #3
  {
    \cs_new_protected:Npn #1 #3
      {
        \int_gincr:N \g__fun_nesting_level_int
        \__fun_one_argument_gset:nn { 1 } { ##1 }
        \__fun_one_argument_gset:nn { 2 } { ##2 }
        \__fun_one_argument_gset:nn { 3 } { ##3 }
        \__fun_one_argument_gset:nn { 4 } { ##4 }
        \__fun_evaluate:Nn #1 {#2}
        \int_gdecr:N \g__fun_nesting_level_int
        \__fun_return_result:
      }
  }
\cs_generate_variant:Nn \__fun_new_with_arg_iv:Nnn { NnV }

%% #1: function name; #2: argument specifications; #3 parameters tl defined
\cs_new_protected:Npn \__fun_new_with_arg_v:Nnn #1 #2 #3
  {
    \cs_new_protected:Npn #1 #3
      {
        \int_gincr:N \g__fun_nesting_level_int
        \__fun_one_argument_gset:nn { 1 } { ##1 }
        \__fun_one_argument_gset:nn { 2 } { ##2 }
        \__fun_one_argument_gset:nn { 3 } { ##3 }
        \__fun_one_argument_gset:nn { 4 } { ##4 }
        \__fun_one_argument_gset:nn { 5 } { ##5 }
        \__fun_evaluate:Nn #1 {#2}
        \int_gdecr:N \g__fun_nesting_level_int
        \__fun_return_result:
      }
  }
\cs_generate_variant:Nn \__fun_new_with_arg_v:Nnn { NnV }

%% #1: function name; #2: argument specifications; #3 parameters tl defined
\cs_new_protected:Npn \__fun_new_with_arg_vi:Nnn #1 #2 #3
  {
    \cs_new_protected:Npn #1 #3
      {
        \int_gincr:N \g__fun_nesting_level_int
        \__fun_one_argument_gset:nn { 1 } { ##1 }
        \__fun_one_argument_gset:nn { 2 } { ##2 }
        \__fun_one_argument_gset:nn { 3 } { ##3 }
        \__fun_one_argument_gset:nn { 4 } { ##4 }
        \__fun_one_argument_gset:nn { 5 } { ##5 }
        \__fun_one_argument_gset:nn { 6 } { ##6 }
        \__fun_evaluate:Nn #1 {#2}
        \int_gdecr:N \g__fun_nesting_level_int
        \__fun_return_result:
      }
  }
\cs_generate_variant:Nn \__fun_new_with_arg_vi:Nnn { NnV }

%% #1: function name; #2: argument specifications; #3 parameters tl defined
\cs_new_protected:Npn \__fun_new_with_arg_vii:Nnn #1 #2 #3
  {
    \cs_new_protected:Npn #1 #3
      {
        \int_gincr:N \g__fun_nesting_level_int
        \__fun_one_argument_gset:nn { 1 } { ##1 }
        \__fun_one_argument_gset:nn { 2 } { ##2 }
        \__fun_one_argument_gset:nn { 3 } { ##3 }
        \__fun_one_argument_gset:nn { 4 } { ##4 }
        \__fun_one_argument_gset:nn { 5 } { ##5 }
        \__fun_one_argument_gset:nn { 6 } { ##6 }
        \__fun_one_argument_gset:nn { 7 } { ##7 }
        \__fun_evaluate:Nn #1 {#2}
        \int_gdecr:N \g__fun_nesting_level_int
        \__fun_return_result:
      }
  }
\cs_generate_variant:Nn \__fun_new_with_arg_vii:Nnn { NnV }

%% #1: function name; #2: argument specifications; #3 parameters tl defined
\cs_new_protected:Npn \__fun_new_with_arg_viii:Nnn #1 #2 #3
  {
    \cs_new_protected:Npn #1 #3
      {
        \int_gincr:N \g__fun_nesting_level_int
        \__fun_one_argument_gset:nn { 1 } { ##1 }
        \__fun_one_argument_gset:nn { 2 } { ##2 }
        \__fun_one_argument_gset:nn { 3 } { ##3 }
        \__fun_one_argument_gset:nn { 4 } { ##4 }
        \__fun_one_argument_gset:nn { 5 } { ##5 }
        \__fun_one_argument_gset:nn { 6 } { ##6 }
        \__fun_one_argument_gset:nn { 7 } { ##7 }
        \__fun_one_argument_gset:nn { 8 } { ##8 }
        \__fun_evaluate:Nn #1 {#2}
        \int_gdecr:N \g__fun_nesting_level_int
        \__fun_return_result:
      }
  }
\cs_generate_variant:Nn \__fun_new_with_arg_viii:Nnn { NnV }

%% #1: function name; #2: argument specifications; #3 parameters tl defined
\cs_new_protected:Npn \__fun_new_with_arg_ix:Nnn #1 #2 #3
  {
    \cs_new_protected:Npn #1 #3
      {
        \int_gincr:N \g__fun_nesting_level_int
        \__fun_one_argument_gset:nn { 1 } { ##1 }
        \__fun_one_argument_gset:nn { 2 } { ##2 }
        \__fun_one_argument_gset:nn { 3 } { ##3 }
        \__fun_one_argument_gset:nn { 4 } { ##4 }
        \__fun_one_argument_gset:nn { 5 } { ##5 }
        \__fun_one_argument_gset:nn { 6 } { ##6 }
        \__fun_one_argument_gset:nn { 7 } { ##7 }
        \__fun_one_argument_gset:nn { 8 } { ##8 }
        \__fun_one_argument_gset:nn { 9 } { ##9 }
        \__fun_evaluate:Nn #1 {#2}
        \int_gdecr:N \g__fun_nesting_level_int
        \__fun_return_result:
      }
  }
\cs_generate_variant:Nn \__fun_new_with_arg_ix:Nnn { NnV }

\tl_new:N \l__fun_argtype_tl
\tl_const:Nn \c__fun_argtype_m_tl { m }
\tl_const:Nn \c__fun_argtype_M_tl { M }
\tl_const:Nn \c__fun_argtype_n_tl { n }
\tl_const:Nn \c__fun_argtype_N_tl { N }
\tl_new:N \l__fun_argument_tl

%% #1: function name; #2: argument specifications
\cs_new_protected:Npn \__fun_evaluate:Nn #1 #2
  {
    \__fun_argtype_index_gzero:
    \__fun_arguments_gclear:
    \tl_map_variable:nNn { #2 } \l__fun_argtype_tl % spaces are ignored
      {
        \__fun_argtype_index_gincr:
        \__fun_one_argument_get:eN { \__fun_argtype_index_use: } \l__fun_argument_tl
        \tl_case:Nn \l__fun_argtype_tl
          {
            \c__fun_argtype_m_tl
              {
                \__fun_evaluate_and_put_argument:N \l__fun_argument_tl
              }
            \c__fun_argtype_M_tl
              {
                \__fun_evaluate_and_put_argument:N \l__fun_argument_tl
              }
            \c__fun_argtype_n_tl
              {
                \__fun_arguments_gput:e { { \exp_not:V \l__fun_argument_tl } }
              }
            \c__fun_argtype_N_tl
              {
                \__fun_arguments_gput:e { \exp_not:V \l__fun_argument_tl }
              }
          }
      }
    \__fun_arguments_log:N #1
    \__fun_arguments_called:c { __fun_defined_ \cs_to_str:N #1 : w }
  }

\cs_new_protected:Npn \__fun_evaluate_and_put_argument:N #1
  {
    \cs_if_exist:cTF
      {
        __fun_defined_ \exp_last_unbraced:Ne \cs_to_str:N { \tl_head:N #1 } : w
      }
      {
        #1
        \__fun_arguments_gput:e { { \exp_not:V \gResultTl } }
      }
      {
        \__fun_arguments_gput:e { { \exp_not:V #1 } }
      }
  }

%% #1: argument number; #2: token lists
\cs_new_protected:Npn \__fun_one_argument_gset:nn #1 #2
  {
    \tl_gset:cn
      { g__fun_one_argument_ \int_use:N \g__fun_nesting_level_int _#1_tl } { #2 }
    %\__fun_one_argument_log:nn { #1 } { set }
  }

%% #1: argument number; #2: variable of token lists
\cs_new_protected:Npn \__fun_one_argument_get:nN #1 #2
  {
    \tl_set_eq:Nc
      #2 { g__fun_one_argument_ \int_use:N \g__fun_nesting_level_int _ #1 _tl }
    %\__fun_one_argument_log:nn { #1 } { get }
  }
\cs_generate_variant:Nn \__fun_one_argument_get:nN { eN }

%% #1: argument number; #2: get or set
\cs_new_protected:Npn \__fun_one_argument_log:nn #1 #2
  {
    \tl_log:e
      {
        #2 ~ level _ \int_use:N \g__fun_nesting_level_int _ arg _ #1 ~ = ~
        \exp_not:v
          { g__fun_one_argument_ \int_use:N \g__fun_nesting_level_int _#1_tl }
      }
  }

\int_new:c  { g__fun_argtype_index_ 1 _int }
\int_new:c  { g__fun_argtype_index_ 2 _int }
\int_new:c  { g__fun_argtype_index_ 3 _int }
\int_new:c  { g__fun_argtype_index_ 4 _int }
\int_new:c  { g__fun_argtype_index_ 5 _int }

\cs_new_protected:Npn \__fun_argtype_index_gzero:
  {
    \int_gzero_new:c
      { g__fun_argtype_index_ \int_use:N \g__fun_nesting_level_int _int }
  }

\cs_new_protected:Npn \__fun_argtype_index_gincr:
  {
    \int_gincr:c
      { g__fun_argtype_index_ \int_use:N \g__fun_nesting_level_int _int }
  }

\cs_new:Npn \__fun_argtype_index_use:
  {
    \int_use:c { g__fun_argtype_index_ \int_use:N \g__fun_nesting_level_int _int }
  }

\cs_new_protected:Npn \__fun_arguments_called:N #1
  {
    \exp_last_unbraced:Nv
      #1 { g__fun_arguments_ \int_use:N \g__fun_nesting_level_int _tl }
  }
\cs_generate_variant:Nn \__fun_arguments_called:N { c }

\cs_new_protected:Npn \__fun_arguments_gclear:
  {
    \tl_gclear:c { g__fun_arguments_ \int_use:N \g__fun_nesting_level_int _tl }
  }

\cs_new_protected:Npn \__fun_arguments_log:N #1
  {
    \__fun_tracing_log:e
    {
      [I] ~ \token_to_str:N #1
     \exp_not:v { g__fun_arguments_ \int_use:N \g__fun_nesting_level_int _tl }
    }
  }

\cs_new_protected:Npn \__fun_arguments_gput:n #1
  {
    \tl_gput_right:cn
      { g__fun_arguments_ \int_use:N \g__fun_nesting_level_int _tl } { #1 }
  }
\cs_generate_variant:Nn \__fun_arguments_gput:n { e }

\cs_set_eq:NN \Break \prg_break:
\cs_set_eq:NN \PrgBreak \prg_break:

\cs_set_eq:NN \BreakDo \prg_break:n
\cs_set_eq:NN \PrgBreakDo \prg_break:n

\cs_new_protected:Npn \__fun_put_result:n #1
  {
    \tl_gput_right:Nn \gResultTl { #1 }
  }
\cs_generate_variant:Nn \__fun_put_result:n { V, e, f, o }

\PrgNewFunction \Return { m }
  {
    \__fun_put_result:n { #1 }
  }
%% Obsolete function, will be removed in the future
\PrgNewFunction \Result { m }
  {
    \__fun_put_result:n { #1 }
  }

%% The result is returned only if the function is not nested in another function
\cs_new_protected:Npn \__fun_return_result:
  {
    \int_compare:nNnT { \g__fun_nesting_level_int } = { 0 } { \FunUseResult }
  }

%% This public command is used in functional library of tabularray package
\cs_new_protected:Npn \FunUseResult
  {
    \tl_use:N \gResultTl
  }

\str_new:N \l__fun_variable_name_str
\str_new:N \l__fun_variable_name_a_str
\str_new:N \l__fun_variable_name_b_str

\prg_new_protected_conditional:Npnn \__fun_if_global_variable:N #1 { TF }
  {
    \str_set:Ne \l__fun_variable_name_str { \cs_to_str:N #1 }
    \str_set:Ne \l__fun_variable_name_b_str
      { \str_item:Nn \l__fun_variable_name_str { 2 } }
    \str_if_eq:VeTF
      \l__fun_variable_name_b_str
      { \str_uppercase:f { \l__fun_variable_name_b_str } }
      {
        \str_set:Ne \l__fun_variable_name_a_str
          { \str_head:N \l__fun_variable_name_str }
        \str_case:VnF \l__fun_variable_name_a_str
          {
            { l } { \prg_return_false: }
            { g } { \prg_return_true: }
          }
          { \__fun_if_set_local: }
      }
      { \__fun_if_set_local: }
  }

\bool_new:N \g__fun_variable_local_bool

\cs_new:Npn \__fun_if_set_local:
  {
    \bool_if:NTF \g__fun_variable_local_bool
      {
        \bool_gset_false:N \g__fun_variable_local_bool
        \prg_return_false:
      }
      { \prg_return_true: }
  }

\PrgNewFunction \Local { } { \bool_gset_true:N \g__fun_variable_local_bool }

%% We must not put an assignment inside a group
\cs_new_protected:Npn \__fun_do_assignment:Nnn #1 #2 #3
  {
    \__fun_group_end:
    \__fun_if_global_variable:NTF #1 { #2 } { #3 }
    \__fun_group_begin:
  }

\bool_new:N \l__fun_scoping_bool

\cs_new_protected:Npn \__fun_scoping_true:
  {
    \cs_set_eq:NN \__fun_group_begin: \group_begin:
    \cs_set_eq:NN \__fun_group_end: \group_end:
  }

\cs_new_protected:Npn \__fun_scoping_false:
  {
    \cs_set_eq:NN \__fun_group_begin: \scan_stop:
    \cs_set_eq:NN \__fun_group_end: \scan_stop:
  }

\cs_new_protected:Npn \__fun_scoping_set:
  {
    \bool_if:NTF \l__fun_scoping_bool
      { \__fun_scoping_true: } { \__fun_scoping_false: }
  }

\bool_new:N \l__fun_tracing_bool
\tl_new:N \l__tracing_text_tl

\cs_new_protected:Npn \__fun_tracing_log_on:n #1
  {
    \tl_set:Ne \l__tracing_text_tl
      {
        \prg_replicate:nn
          { \int_eval:n { (\g__fun_nesting_level_int - 1) * 4 } } { ~ }
      }
    \tl_put_right:Nn \l__tracing_text_tl { #1 }
    \iow_log:V \l__tracing_text_tl
  }
\cs_generate_variant:Nn \__fun_tracing_log_on:n { e, V }

\cs_new_protected:Npn \__fun_tracing_log_off:n #1 { }
\cs_new_protected:Npn \__fun_tracing_log_off:e #1 { }
\cs_new_protected:Npn \__fun_tracing_log_off:V #1 { }

\cs_new_protected:Npn \__fun_tracing_true:
  {
    \cs_set_eq:NN \__fun_tracing_log:n \__fun_tracing_log_on:n
    \cs_set_eq:NN \__fun_tracing_log:e \__fun_tracing_log_on:e
    \cs_set_eq:NN \__fun_tracing_log:V \__fun_tracing_log_on:V
  }

\cs_new_protected:Npn \__fun_tracing_false:
  {
    \cs_set_eq:NN \__fun_tracing_log:n \__fun_tracing_log_off:n
    \cs_set_eq:NN \__fun_tracing_log:e \__fun_tracing_log_off:e
    \cs_set_eq:NN \__fun_tracing_log:V \__fun_tracing_log_off:V
  }

\cs_new_protected:Npn \__fun_tracing_set:
  {
    \bool_if:NTF \l__fun_tracing_bool
      { \__fun_tracing_true: } { \__fun_tracing_false: }
  }

\keys_define:nn { functional }
  {
    scoping .bool_set:N = \l__fun_scoping_bool,
    tracing .bool_set:N = \l__fun_tracing_bool,
  }

\NewDocumentCommand \Functional { m }
  {
    \keys_set:nn { functional } { #1 }
    \__fun_scoping_set:
    \__fun_tracing_set:
  }

\Functional { scoping = false, tracing = false }

\cs_new_protected:Npn \__fun_ignore_spaces_on:
  {
    \ExplSyntaxOn
    \char_set_catcode_math_subscript:N \_
    \char_set_catcode_other:N \:
  }
\cs_set_eq:NN \IgnoreSpacesOn \__fun_ignore_spaces_on:
\cs_set_eq:NN \IgnoreSpacesOff \ExplSyntaxOff

%%% --------------------------------------------------------
%%> \section{Interfaces for Argument Using (Use)}
%%% --------------------------------------------------------

\PrgNewFunction \Name { m }
  {
    \exp_args:Nc \__fun_put_result:n { #1 }
  }
\PrgNewFunction \ExpName { m }
  {
    \exp_args:Nc \__fun_put_result:n { #1 }
  }

\PrgNewFunction \Value { M }
  {
    \__fun_put_result:V #1
  }
\PrgNewFunction \ExpValue { M }
  {
    \__fun_put_result:V #1
  }

\PrgNewFunction \Expand { m }
  {
    \__fun_put_result:e { #1 }
  }
\PrgNewFunction \ExpWhole { m }
  {
    \__fun_put_result:e { #1 }
  }

\PrgNewFunction \ExpPartial { m }
  {
    \__fun_put_result:f { #1 }
  }

\PrgNewFunction \ExpOnce { m }
  {
    \__fun_put_result:o { #1 }
  }

\cs_set_eq:NN \UnExpand    \exp_not:n
\cs_set_eq:NN \NoExpand    \exp_not:N
\cs_set_eq:NN \OnlyName    \exp_not:c
\cs_set_eq:NN \OnlyValue   \exp_not:V
\cs_set_eq:NN \OnlyPartial \exp_not:f
\cs_set_eq:NN \OnlyOnce    \exp_not:o

\PrgNewFunction \UseOne { n } { \Return { #1 } }

\PrgNewFunction \GobbleOne { n } { \Return { } }

\PrgNewFunction \UseGobble { n n } { \UseOne { #1 } }

\PrgNewFunction \GobbleUse { n n } { \UseOne { #2 } }

%%% --------------------------------------------------------
%%> \section{Interfaces for Control Structures (Bool)}
%%% --------------------------------------------------------

\bool_const:Nn \cTrueBool { \c_true_bool }
\bool_const:Nn \cFalseBool { \c_false_bool }

\bool_new:N \lTmpaBool   \bool_new:N \lTmpbBool   \bool_new:N \lTmpcBool
\bool_new:N \lTmpiBool   \bool_new:N \lTmpjBool   \bool_new:N \lTmpkBool
\bool_new:N \l@Funx@Bool \bool_new:N \l@Funy@Bool \bool_new:N \l@Funz@Bool

\bool_new:N \gTmpaBool   \bool_new:N \gTmpbBool   \bool_new:N \gTmpcBool
\bool_new:N \gTmpiBool   \bool_new:N \gTmpjBool   \bool_new:N \gTmpkBool
\bool_new:N \g@Funx@Bool \bool_new:N \g@Funy@Bool \bool_new:N \g@Funz@Bool

\PrgNewFunction \BoolNew { M } { \bool_new:N #1 }

\PrgNewFunction \BoolConst { M m } { \bool_const:Nn #1 { #2 } }

\PrgNewFunction \BoolSet { M m } {
  \__fun_do_assignment:Nnn #1
    { \bool_gset:Nn #1 { #2 } } { \bool_set:Nn #1 { #2 } }
}

\PrgNewFunction \BoolSetTrue { M }
  {
    \__fun_do_assignment:Nnn #1 { \bool_gset_true:N #1 } { \bool_set_true:N #1 }
  }

\PrgNewFunction \BoolSetFalse { M }
  {
    \__fun_do_assignment:Nnn #1 { \bool_gset_false:N #1 } { \bool_set_false:N #1 }
  }

\PrgNewFunction \BoolSetEq { M M }
  {
    \__fun_do_assignment:Nnn #1
      { \bool_gset_eq:NN #1 #2 } { \bool_set_eq:NN #1 #2 }
  }

\PrgNewFunction \BoolLog { m } { \bool_log:n { #1 } }

\PrgNewFunction \BoolVarLog { M } { \bool_log:N #1 }

\PrgNewFunction \BoolShow { m } { \bool_show:n { #1 } }

\PrgNewFunction \BoolVarShow { M } { \bool_show:N #1 }

\PrgNewConditional \BoolIfExist { M }
  {
    \bool_if_exist:NTF #1 { \Return { \cTrueBool } } { \Return { \cFalseBool } }
  }

\PrgNewConditional \BoolVarIf { M } { \Return { #1 } }

\PrgNewConditional \BoolVarNot { M }
  {
    \bool_if:NTF #1
      { \Return { \cFalseBool } } { \Return { \cTrueBool } }
  }

\PrgNewConditional \BoolVarAnd { M M }
  {
    \bool_lazy_and:nnTF {#1} {#2}
      { \Return { \cTrueBool } } { \Return { \cFalseBool } }
  }

\PrgNewConditional \BoolVarOr { M M }
  {
    \bool_lazy_or:nnTF {#1} {#2}
      { \Return { \cTrueBool } } { \Return { \cFalseBool } }
  }

\PrgNewConditional \BoolVarXor { M M }
  {
    \bool_xor:nnTF {#1} {#2}
      { \Return { \cTrueBool } } { \Return { \cFalseBool } }
  }

\PrgNewFunction \BoolVarDoUntil { N n }
  {
    \bool_do_until:Nn #1 {#2}
  }

\PrgNewFunction \BoolVarDoWhile { N n }
  {
    \bool_do_while:Nn #1 {#2}
  }

\PrgNewFunction \BoolVarUntilDo { N n }
  {
    \bool_until_do:Nn #1 {#2}
  }

\PrgNewFunction \BoolVarWhileDo { N n }
  {
    \bool_while_do:Nn #1 {#2}
  }

%%% --------------------------------------------------------
%%> \section{Interfaces for Token Lists (Tl)}
%%% --------------------------------------------------------

\tl_set_eq:NN \cEmptyTl \c_empty_tl
\tl_set_eq:NN \cSpaceTl \c_space_tl
\tl_set_eq:NN \cNoValueTl \c_novalue_tl

\tl_new:N \lTmpaTl   \tl_new:N \lTmpbTl   \tl_new:N \lTmpcTl
\tl_new:N \lTmpiTl   \tl_new:N \lTmpjTl   \tl_new:N \lTmpkTl
\tl_new:N \l@Funx@Tl \tl_new:N \l@Funy@Tl \tl_new:N \l@Funz@Tl

\tl_new:N \gTmpaTl   \tl_new:N \gTmpbTl   \tl_new:N \gTmpcTl
\tl_new:N \gTmpiTl   \tl_new:N \gTmpjTl   \tl_new:N \gTmpkTl
\tl_new:N \g@Funx@Tl \tl_new:N \g@Funy@Tl \tl_new:N \g@Funz@Tl

\PrgNewFunction \TlNew { M } { \tl_new:N #1 }

\PrgNewFunction \TlLog { m } { \tl_log:n { #1 } }

\PrgNewFunction \TlVarLog { M } { \tl_log:N #1 }

\PrgNewFunction \TlShow { m } { \tl_show:n { #1 } }

\PrgNewFunction \TlVarShow { M } { \tl_show:N #1 }

\PrgNewFunction \TlUse { M } { \Return { \Value #1 } }

\PrgNewFunction \TlToStr { m } { \Expand { \tl_to_str:n { #1 } } }

\PrgNewFunction \TlVarToStr { M } { \Expand { \tl_to_str:N #1 } }

\PrgNewFunction \TlConst { M m } { \tl_const:Nn #1 { #2 } }

\PrgNewFunction \TlSet { M m }
  {
    \__fun_do_assignment:Nnn #1 { \tl_gset:Nn #1 {#2} } { \tl_set:Nn #1 {#2} }
  }

\PrgNewFunction \TlSetEq { M M }
  {
    \__fun_do_assignment:Nnn #1 { \tl_gset_eq:NN #1 #2 } { \tl_set_eq:NN #1 #2 }
  }

\PrgNewFunction \TlConcat { M M M }
  {
    \__fun_do_assignment:Nnn #1
      { \tl_gconcat:NNN #1 #2 #3 } { \tl_concat:NNN #1 #2 #3 }
  }

\PrgNewFunction \TlClear { M }
  {
    \__fun_do_assignment:Nnn #1 { \tl_gclear:N #1 } { \tl_clear:N #1 }
  }

\PrgNewFunction \TlClearNew { M }
  {
    \__fun_do_assignment:Nnn #1 { \tl_gclear_new:N #1 } { \tl_clear_new:N #1 }
  }

\PrgNewFunction \TlPutLeft { M m }
  {
    \__fun_do_assignment:Nnn #1
      { \tl_gput_left:Nn #1 {#2} } { \tl_put_left:Nn #1 {#2} }
  }

\PrgNewFunction \TlPutRight { M m }
  {
    \__fun_do_assignment:Nnn #1
      { \tl_gput_right:Nn #1 {#2} } { \tl_put_right:Nn #1 {#2} }
  }

\PrgNewFunction \TlVarReplaceOnce { M m m }
  {
    \__fun_do_assignment:Nnn #1
      { \tl_greplace_once:Nnn #1 {#2} {#3} } { \tl_replace_once:Nnn #1 {#2} {#3} }
  }

\PrgNewFunction \TlVarReplaceAll { M m m }
  {
    \__fun_do_assignment:Nnn #1
      { \tl_greplace_all:Nnn #1 {#2} {#3} } { \tl_replace_all:Nnn #1 {#2} {#3} }
  }

\PrgNewFunction \TlVarRemoveOnce { M m }
  {
    \__fun_do_assignment:Nnn #1
      { \tl_gremove_once:Nn #1 {#2} } { \tl_remove_once:Nn #1 {#2} }
  }

\PrgNewFunction \TlVarRemoveAll { M m }
  {
    \__fun_do_assignment:Nnn #1
      { \tl_gremove_all:Nn #1 {#2} } { \tl_remove_all:Nn #1 {#2} }
  }

\PrgNewFunction \TlTrimSpaces { m } { \Expand { \tl_trim_spaces:n { #1 } } }

\PrgNewFunction \TlVarTrimSpaces { M }
  {
    \__fun_do_assignment:Nnn #1 { \tl_gtrim_spaces:N #1 } { \tl_trim_spaces:N #1 }
  }

\PrgNewFunction \TlCount { m } { \Expand { \tl_count:n { #1 } } }

\PrgNewFunction \TlVarCount { M } { \Expand { \tl_count:N #1 } }

\PrgNewFunction \TlHead { m } { \Expand { \tl_head:n { #1 } } }

\PrgNewFunction \TlVarHead { M } { \Expand { \tl_head:N #1 } }

\PrgNewFunction \TlTail { m } { \Expand { \tl_tail:n { #1 } } }

\PrgNewFunction \TlVarTail { M } { \Expand { \tl_tail:N #1 } }

\PrgNewFunction \TlItem { m m } { \Expand { \tl_item:nn {#1} {#2} } }

\PrgNewFunction \TlVarItem { M m } { \Expand { \tl_item:Nn #1 {#2} } }

\PrgNewFunction \TlRandItem { m } { \Expand { \tl_rand_item:n {#1} } }

\PrgNewFunction \TlVarRandItem { M } { \Expand { \tl_rand_item:N #1 } }

\PrgNewFunction \TlVarCase   { M m }     { \tl_case:Nn {#1} {#2} }
\PrgNewFunction \TlVarCaseT  { M m n }   { \tl_case:NnT {#1} {#2} {#3} }
\PrgNewFunction \TlVarCaseF  { M m n }   { \tl_case:NnF {#1} {#2} {#3} }
\PrgNewFunction \TlVarCaseTF { M m n n } { \tl_case:NnTF {#1} {#2} {#3} {#4} }

\PrgNewFunction \TlMapInline { m n }
  {
    \tl_map_inline:nn {#1} {#2}
  }

\PrgNewFunction \TlVarMapInline { M n }
  {
    \tl_map_inline:Nn #1 {#2}
  }

\PrgNewFunction \TlMapVariable { m M n }
  {
    \tl_map_variable:nNn {#1} #2 {#3}
  }

\PrgNewFunction \TlVarMapVariable { M M n }
  {
    \tl_map_variable:NNn #1 #2 {#3}
  }

\PrgNewConditional \TlIfExist { M }
  {
    \tl_if_exist:NTF #1 { \Return { \cTrueBool } }  { \Return { \cFalseBool } }
  }

\PrgNewConditional \TlIfEmpty { m }
  {
    \tl_if_empty:nTF {#1} { \Return { \cTrueBool } }  { \Return { \cFalseBool } }
  }

\PrgNewConditional \TlVarIfEmpty { M }
  {
    \tl_if_empty:NTF #1 { \Return { \cTrueBool } }  { \Return { \cFalseBool } }
  }

\PrgNewConditional \TlIfBlank { m }
  {
    \tl_if_blank:nTF {#1} { \Return { \cTrueBool } }  { \Return { \cFalseBool } }
  }

\PrgNewConditional \TlIfEq { m m }
  {
    \tl_if_eq:nnTF {#1} {#2} { \Return { \cTrueBool } } { \Return { \cFalseBool } }
  }

\PrgNewConditional \TlVarIfEq { M M }
  {
    \tl_if_eq:NNTF #1 #2 { \Return { \cTrueBool } } { \Return { \cFalseBool } }
  }

\PrgNewConditional \TlIfIn { m m }
  {
    \tl_if_in:nnTF {#1} {#2} { \Return { \cTrueBool } } { \Return { \cFalseBool } }
  }

\PrgNewConditional \TlVarIfIn { M m }
  {
    \tl_if_in:NnTF #1 {#2} { \Return { \cTrueBool } } { \Return { \cFalseBool } }
  }

\PrgNewConditional \TlIfSingle { m }
  {
    \tl_if_single:nTF {#1} { \Return { \cTrueBool } } { \Return { \cFalseBool } }
  }

\PrgNewConditional \TlVarIfSingle { M }
  {
    \tl_if_single:NTF #1 { \Return { \cTrueBool } } { \Return { \cFalseBool } }
  }

%%% --------------------------------------------------------
%%> \section{Interfaces for Strings (Str)}
%%% --------------------------------------------------------

\str_set_eq:NN \cAmpersandStr  \c_ampersand_str
\str_set_eq:NN \cAttignStr     \c_atsign_str
\str_set_eq:NN \cBackslashStr  \c_backslash_str
\str_set_eq:NN \cLeftBraceStr  \c_left_brace_str
\str_set_eq:NN \cRightBraceStr \c_right_brace_str
\str_set_eq:NN \cCircumflexStr \c_circumflex_str
\str_set_eq:NN \cColonStr      \c_colon_str
\str_set_eq:NN \cDollarStr     \c_dollar_str
\str_set_eq:NN \cHashStr       \c_hash_str
\str_set_eq:NN \cPercentStr    \c_percent_str
\str_set_eq:NN \cTildeStr      \c_tilde_str
\str_set_eq:NN \cUnderscoreStr \c_underscore_str
\str_set_eq:NN \cZeroStr       \c_zero_str

\str_new:N \lTmpaStr   \str_new:N \lTmpbStr   \str_new:N \lTmpcStr
\str_new:N \lTmpiStr   \str_new:N \lTmpjStr   \str_new:N \lTmpkStr
\str_new:N \l@Funx@Str \str_new:N \l@Funy@Str \str_new:N \l@Funz@Str

\str_new:N \gTmpaStr   \str_new:N \gTmpbStr   \str_new:N \gTmpcStr
\str_new:N \gTmpiStr   \str_new:N \gTmpjStr   \str_new:N \gTmpkStr
\str_new:N \g@Funx@Str \str_new:N \g@Funy@Str \str_new:N \g@Funz@Str

\PrgNewFunction \StrNew { M } { \str_new:N #1 }

\PrgNewFunction \StrLog { m } { \str_log:n { #1 } }

\PrgNewFunction \StrVarLog { M } { \str_log:N #1 }

\PrgNewFunction \StrShow { m } { \str_show:n { #1 } }

\PrgNewFunction \StrVarShow { M } { \str_show:N #1 }

\PrgNewFunction \StrUse { M } { \Return { \Value #1 } }

\PrgNewFunction \StrConst { M m } { \str_const:Nn #1 {#2} }

\PrgNewFunction \StrSet { M m }
  {
    \__fun_do_assignment:Nnn #1 { \str_gset:Nn #1 {#2} } { \str_set:Nn #1 {#2} }
  }

\PrgNewFunction \StrSetEq { M M }
  {
    \__fun_do_assignment:Nnn #1 { \str_gset_eq:NN #1 #2 } { \str_set_eq:NN #1 #2 }
  }

\PrgNewFunction \StrConcat { M M M }
  {
    \__fun_do_assignment:Nnn #1
      { \str_gconcat:NNN #1 #2 #3 } { \str_concat:NNN #1 #2 #3 }
  }

\PrgNewFunction \StrClear { M }
  {
    \__fun_do_assignment:Nnn #1 { \str_gclear:N #1 } { \str_clear:N #1 }
  }

\PrgNewFunction \StrClearNew { M }
  {
    \__fun_do_assignment:Nnn #1 { \str_gclear_new:N #1 } { \str_clear_new:N #1 }
  }

\PrgNewFunction \StrPutLeft { M m }
  {
    \__fun_do_assignment:Nnn #1
      { \str_gput_left:Nn #1 {#2} } { \str_put_left:Nn #1 {#2} }
  }

\PrgNewFunction \StrPutRight { M m }
  {
    \__fun_do_assignment:Nnn #1
      { \str_gput_right:Nn #1 {#2} } { \str_put_right:Nn #1 {#2} }
  }

\PrgNewFunction \StrVarReplaceOnce { M m m }
  {
    \__fun_do_assignment:Nnn #1
      { \str_greplace_once:Nnn #1 {#2} {#3} } { \str_replace_once:Nnn #1 {#2} {#3} }
  }

\PrgNewFunction \StrVarReplaceAll { M m m }
  {
    \__fun_do_assignment:Nnn #1
      { \str_greplace_all:Nnn #1 {#2} {#3} } { \str_replace_all:Nnn #1 {#2} {#3} }
  }

\PrgNewFunction \StrVarRemoveOnce { M m }
  {
    \__fun_do_assignment:Nnn #1
      { \str_gremove_once:Nn #1 {#2} } { \str_remove_once:Nn #1 {#2} }
  }

\PrgNewFunction \StrVarRemoveAll { M m }
  {
    \__fun_do_assignment:Nnn #1
      { \str_gremove_all:Nn #1 {#2} } { \str_remove_all:Nn #1 {#2} }
  }

%% Avoid naming confict with xstring package
\cs_if_exist:NF \StrCount
  { \PrgNewFunction \StrCount { m } { \Expand { \str_count:n { #1 } } } }

%% Provide another name for \StrCount function
\PrgNewFunction \StrSize { m } { \Expand { \str_count:n { #1 } } }

\PrgNewFunction \StrVarCount { M } { \Expand { \str_count:N #1 } }

\PrgNewFunction \StrHead { m } { \Expand { \str_head:n { #1 } } }

\PrgNewFunction \StrVarHead { M } { \Expand { \str_head:N #1 } }

\PrgNewFunction \StrTail { m } { \Expand { \str_tail:n { #1 } } }

\PrgNewFunction \StrVarTail { M } { \Expand { \str_tail:N #1 } }

\PrgNewFunction \StrItem { m m } { \Expand { \str_item:nn {#1} {#2} } }

\PrgNewFunction \StrVarItem { M m } { \Expand { \str_item:Nn #1 {#2} } }

\PrgNewFunction \StrCase   { m m }     { \str_case:nn {#1} {#2} }
\PrgNewFunction \StrCaseT  { m m n }   { \str_case:nnT {#1} {#2} {#3} }
\PrgNewFunction \StrCaseF  { m m n }   { \str_case:nnF {#1} {#2} {#3} }
\PrgNewFunction \StrCaseTF { m m n n } { \str_case:nnTF {#1} {#2} {#3} {#4} }

\PrgNewFunction \StrMapInline { m n }
  {
    \str_map_inline:nn {#1} {#2}
  }

\PrgNewFunction \StrVarMapInline { M n }
  {
    \str_map_inline:Nn #1 {#2}
  }

\PrgNewFunction \StrMapVariable { m M n }
  {
    \str_map_variable:nNn {#1} #2 {#3}
  }

\PrgNewFunction \StrVarMapVariable { M M n }
  {
    \str_map_variable:NNn #1 #2 {#3}
  }

\PrgNewConditional \StrIfExist { M }
  {
    \str_if_exist:NTF #1 { \Return { \cTrueBool } }  { \Return { \cFalseBool } }
  }

\PrgNewConditional \StrVarIfEmpty { M }
  {
    \str_if_empty:NTF #1 { \Return { \cTrueBool } } { \Return { \cFalseBool } }
  }

\PrgNewConditional \StrIfEq { m m }
  {
    \str_if_eq:nnTF {#1} {#2} { \Return { \cTrueBool } } { \Return { \cFalseBool } }
  }

\PrgNewConditional \StrVarIfEq { M M }
  {
    \str_if_eq:NNTF #1 #2 { \Return { \cTrueBool } } { \Return { \cFalseBool } }
  }

\PrgNewConditional \StrIfIn { m m }
  {
    \str_if_in:nnTF {#1} {#2} { \Return { \cTrueBool } } { \Return { \cFalseBool } }
  }

\PrgNewConditional \StrVarIfIn { M m }
  {
    \str_if_in:NnTF #1 {#2} { \Return { \cTrueBool } } { \Return { \cFalseBool } }
  }

%% Avoid naming confict with xstring package
\cs_if_exist:NF \StrCompare
  {
    \PrgNewConditional \StrCompare { m N m }
      {
        \str_compare:nNnTF {#1} #2 {#3}
          { \Return { \cTrueBool } }
          { \Return { \cFalseBool } }
      }
  }

%% Provide another name for \StrCompare function
\PrgNewConditional \StrIfCompare { m N m }
  {
    \str_compare:nNnTF {#1} #2 {#3}
      { \Return { \cTrueBool } }
      { \Return { \cFalseBool } }
  }

%%% --------------------------------------------------------
%%> \section{Interfaces for Integers (Int)}
%%% --------------------------------------------------------

\cs_set_eq:NN \cZeroInt        \c_zero_int
\cs_set_eq:NN \cOneInt         \c_one_int
\cs_set_eq:NN \cMaxInt         \c_max_int
\cs_set_eq:NN \cMaxRegisterInt \c_max_register_int
\cs_set_eq:NN \cMaxCharInt     \c_max_char_in

\int_new:N \lTmpaInt   \int_new:N \lTmpbInt   \int_new:N \lTmpcInt
\int_new:N \lTmpiInt   \int_new:N \lTmpjInt   \int_new:N \lTmpkInt
\int_new:N \l@Funx@Int \int_new:N \l@Funy@Int \int_new:N \l@Funz@Int

\int_new:N \gTmpaInt   \int_new:N \gTmpbInt   \int_new:N \gTmpcInt
\int_new:N \gTmpiInt   \int_new:N \gTmpjInt   \int_new:N \gTmpkInt
\int_new:N \g@Funx@Int \int_new:N \g@Funy@Int \int_new:N \g@Funz@Int

\PrgNewFunction \IntEval { m }
  {
    \Return { \Expand { \int_eval:n { #1 } } }
  }

\PrgNewFunction \IntMathAdd { m m }
  {
    \int_set:Nn \l@Funx@Int { \int_eval:n { (#1) + (#2) } }
    \Return { \Value \l@Funx@Int }
  }

\PrgNewFunction \IntMathSub { m m }
  {
    \int_set:Nn \l@Funx@Int { \int_eval:n { (#1) - (#2) } }
    \Return { \Value \l@Funx@Int }
  }

\PrgNewFunction \IntMathMult { m m }
  {
    \int_set:Nn \l@Funx@Int { \int_eval:n { (#1) * (#2) } }
    \Return { \Value \l@Funx@Int }
  }

\PrgNewFunction \IntMathDiv { m m }
  {
    \Expand { \int_div_round:nn { #1 } { #2 } }
  }

\PrgNewFunction \IntMathDivTruncate { m m }
  {
    \Expand { \int_div_truncate:nn { #1 } { #2 } }
  }

\PrgNewFunction \IntMathSign { m } { \Expand { \int_sign:n { #1 } } }

\PrgNewFunction \IntMathAbs { m } { \Expand { \int_abs:n { #1 } } }

\PrgNewFunction \IntMathMax { m m } { \Expand { \int_max:nn { #1 } { #2 } } }

\PrgNewFunction \IntMathMin { m m } { \Expand { \int_min:nn { #1 } { #2 } } }

\PrgNewFunction \IntMathMod { m m } { \Expand { \int_mod:nn { #1 } { #2 } } }

\PrgNewFunction \IntMathRand { m m } { \Expand { \int_rand:nn { #1 } { #2 } } }

\PrgNewFunction \IntNew { M } { \int_new:N #1 }

\PrgNewFunction \IntConst { M m } { \int_const:Nn #1 { #2 } }

\PrgNewFunction \IntLog { m } { \int_log:n { #1 } }

\PrgNewFunction \IntVarLog { M } { \int_log:N #1 }

\PrgNewFunction \IntShow { m } { \int_show:n { #1 } }

\PrgNewFunction \IntVarShow { M } { \int_show:N #1 }

\PrgNewFunction \IntUse { M } { \Return { \Value #1 } }

\PrgNewFunction \IntSet { M m }
  {
    \__fun_do_assignment:Nnn #1 { \int_gset:Nn #1 {#2} } { \int_set:Nn #1 {#2} }
  }

\PrgNewFunction \IntZero { M }
  {
    \__fun_do_assignment:Nnn #1 { \int_gzero:N #1 } { \int_zero:N #1 }
  }

\PrgNewFunction \IntZeroNew { M }
  {
    \__fun_do_assignment:Nnn #1 { \int_gzero_new:N #1 } { \int_zero_new:N #1 }
  }

\PrgNewFunction \IntSetEq { M M }
  {
    \__fun_do_assignment:Nnn #1 { \int_gset_eq:NN #1 #2 } { \int_set_eq:NN #1 #2 }
  }

\PrgNewFunction \IntIncr { M }
  {
    \__fun_do_assignment:Nnn #1 { \int_gincr:N #1 } { \int_incr:N #1 }
  }

\PrgNewFunction \IntDecr { M }
  {
    \__fun_do_assignment:Nnn #1 { \int_gdecr:N #1 } { \int_decr:N #1 }
  }

\PrgNewFunction \IntAdd { M m }
  {
    \__fun_do_assignment:Nnn #1 { \int_gadd:Nn #1 {#2} } { \int_add:Nn #1 {#2} }
  }

\PrgNewFunction \IntSub { M m }
  {
    \__fun_do_assignment:Nnn #1 { \int_gsub:Nn #1 {#2} } { \int_sub:Nn #1 {#2} }
  }

\PrgNewFunction \IntStepInline { m m m n }
  {
    \int_step_inline:nnnn { #1 } { #2 } { #3 } { #4 }
  }

\PrgNewFunction \IntStepVariable { m m m M n }
  {
    \int_step_variable:nnnNn { #1 } { #2 } { #3 } #4 { #5 }
  }

\PrgNewConditional \IntIfExist { M }
  {
    \int_if_exist:NTF #1 { \Return { \cTrueBool } } { \Return { \cFalseBool } }
  }

\PrgNewConditional \IntIfOdd { m }
  {
    \int_if_odd:nTF { #1 } { \Return { \cTrueBool } } { \Return { \cFalseBool } }
  }

\PrgNewConditional \IntIfEven { m }
  {
    \int_if_even:nTF { #1 } { \Return { \cTrueBool } } { \Return { \cFalseBool } }
  }

\PrgNewConditional \IntCompare { m N m }
  {
    \int_compare:nNnTF {#1} #2 {#3}
      { \Return { \cTrueBool } }
      { \Return { \cFalseBool } }
  }

\PrgNewFunction \IntCase   { m m }     { \int_case:nn {#1} {#2} }
\PrgNewFunction \IntCaseT  { m m n }   { \int_case:nnT {#1} {#2} {#3} }
\PrgNewFunction \IntCaseF  { m m n }   { \int_case:nnF {#1} {#2} {#3} }
\PrgNewFunction \IntCaseTF { m m n n } { \int_case:nnTF {#1} {#2} {#3} {#4} }

%%% --------------------------------------------------------
%%> \section{Interfaces for Floating Point Numbers (Fp)}
%%% --------------------------------------------------------

\fp_set_eq:NN \cZeroFp      \c_zero_fp
\fp_set_eq:NN \cMinusZeroFp \c_minus_zero_fp
\fp_set_eq:NN \cOneFp       \c_one_fp
\fp_set_eq:NN \cInfFp       \c_inf_fp
\fp_set_eq:NN \cMinusInfFp  \c_minus_inf_fp
\fp_set_eq:NN \cEFp         \c_e_fp
\fp_set_eq:NN \cPiFp        \c_pi_fp
\fp_set_eq:NN \cOneDegreeFp \c_one_degree_fp

\fp_new:N \lTmpaFp   \fp_new:N \lTmpbFp   \fp_new:N \lTmpcFp
\fp_new:N \lTmpiFp   \fp_new:N \lTmpjFp   \fp_new:N \lTmpkFp
\fp_new:N \l@Funx@Fp \fp_new:N \l@Funy@Fp \fp_new:N \l@Funz@Fp

\fp_new:N \gTmpaFp   \fp_new:N \gTmpbFp   \fp_new:N \gTmpcFp
\fp_new:N \gTmpiFp   \fp_new:N \gTmpjFp   \fp_new:N \gTmpkFp
\fp_new:N \g@Funx@Fp \fp_new:N \g@Funy@Fp \fp_new:N \g@Funz@Fp

\PrgNewFunction \FpEval { m }
  {
    \Return { \Expand { \fp_eval:n { #1 } } }
  }

\PrgNewFunction \FpMathAdd { m m }
  {
    \fp_set:Nn \l@Funx@Fp { \fp_eval:n { (#1) + (#2) } }
    \Return { \FpUse \l@Funx@Fp }
  }

\PrgNewFunction \FpMathSub { m m }
  {
    \fp_set:Nn \l@Funx@Fp { \fp_eval:n { (#1) - (#2) } }
    \Return { \FpUse \l@Funx@Fp }
  }

\PrgNewFunction \FpMathMult { m m }
  {
    \fp_set:Nn \l@Funx@Fp { \fp_eval:n { (#1) * (#2) } }
    \Return { \FpUse \l@Funx@Fp }
  }

\PrgNewFunction \FpMathDiv { m m }
  {
    \fp_set:Nn \l@Funx@Fp { \fp_eval:n { (#1) / (#2) } }
    \Return { \FpUse \l@Funx@Fp }
  }

\PrgNewFunction \FpMathSign { m }
  {
    \Return { \Expand { \fp_sign:n { #1 } } }
  }

\PrgNewFunction \FpMathAbs { m }
  {
    \Return { \Expand { \fp_abs:n { #1 } } }
  }

\PrgNewFunction \FpMathMax { m m }
  {
    \Return { \Expand { \fp_max:nn { #1 } { #2 } } }
  }

\PrgNewFunction \FpMathMin { m m }
  {
    \Return { \Expand { \fp_min:nn { #1 } { #2 } } }
  }

\PrgNewFunction \FpNew { M } { \fp_new:N #1 }

\PrgNewFunction \FpConst { M m } { \fp_const:Nn #1 {#2} }

\PrgNewFunction \FpUse { M } { \Return { \Expand { \fp_use:N #1 } } }

\PrgNewFunction \FpLog { m } { \fp_log:n { #1 } }

\PrgNewFunction \FpVarLog { M } { \fp_log:N #1 }

\PrgNewFunction \FpShow { m } { \fp_show:n { #1 } }

\PrgNewFunction \FpVarShow { M } { \fp_show:N #1 }

\PrgNewFunction \FpSet { M m }
  {
    \__fun_do_assignment:Nnn #1 { \fp_gset:Nn #1 {#2} } { \fp_set:Nn #1 {#2} }
  }

\PrgNewFunction \FpSetEq { M M }
  {
    \__fun_do_assignment:Nnn #1 { \fp_gset_eq:NN #1 #2 } { \fp_set_eq:NN #1 #2 }
  }

\PrgNewFunction \FpZero { M }
  {
    \__fun_do_assignment:Nnn #1 { \fp_gzero:N #1 } { \fp_zero:N #1 }
  }

\PrgNewFunction \FpZeroNew { M }
  {
    \__fun_do_assignment:Nnn #1 { \fp_gzero_new:N #1 } { \fp_zero_new:N #1 }
  }

\PrgNewFunction \FpAdd { M m }
  {
    \__fun_do_assignment:Nnn #1 { \fp_gadd:Nn #1 {#2} } { \fp_add:Nn #1 {#2} }
  }

\PrgNewFunction \FpSub { M m }
  {
    \__fun_do_assignment:Nnn #1 { \fp_gsub:Nn #1 {#2} } { \fp_sub:Nn #1 {#2} }
  }

\PrgNewFunction \FpStepInline { m m m n }
  {
    \fp_step_inline:nnnn { #1 } { #2 } { #3 } { #4 }
  }

\PrgNewFunction \FpStepVariable { m m m M n }
  {
    \fp_step_variable:nnnNn { #1 } { #2 } { #3 } #4 { #5 }
  }

\PrgNewConditional \FpIfExist { M }
  {
    \fp_if_exist:NTF #1 { \Return { \cTrueBool } } { \Return { \cFalseBool } }
  }

\PrgNewConditional \FpCompare { m N m }
  {
    \fp_compare:nNnTF {#1} #2 {#3}
      { \Return { \cTrueBool } }
      { \Return { \cFalseBool } }
  }

%%% --------------------------------------------------------
%%> \section{Interfaces for Dimensions (Dim)}
%%% --------------------------------------------------------

\cs_set_eq:NN \cMaxDim  \c_max_dim
\cs_set_eq:NN \cZeroDim \c_zero_dim

\dim_new:N \lTmpaDim   \dim_new:N \lTmpbDim   \dim_new:N \lTmpcDim
\dim_new:N \lTmpiDim   \dim_new:N \lTmpjDim   \dim_new:N \lTmpkDim
\dim_new:N \l@Funx@Dim \dim_new:N \l@Funy@Dim \dim_new:N \l@Funz@Dim

\dim_new:N \gTmpaDim   \dim_new:N \gTmpbDim   \dim_new:N \gTmpcDim
\dim_new:N \gTmpiDim   \dim_new:N \gTmpjDim   \dim_new:N \gTmpkDim
\dim_new:N \g@Funx@Dim \dim_new:N \g@Funy@Dim \dim_new:N \g@Funz@Dim

\PrgNewFunction \DimEval { m }
  {
    \Return { \Expand { \dim_eval:n { #1 } } }
  }

\PrgNewFunction \DimMathAdd { m m }
  {
    \dim_set:Nn \l@Funx@Dim { \dim_eval:n { (#1) + (#2) } }
    \Return { \Value \l@Funx@Dim }
  }

\PrgNewFunction \DimMathSub { m m }
  {
    \dim_set:Nn \l@Funx@Dim { \dim_eval:n { (#1) - (#2) } }
    \Return { \Value \l@Funx@Dim }
  }

\PrgNewFunction \DimMathSign { m }
  {
    \Return { \Expand { \dim_sign:n { #1 } } }
  }

\PrgNewFunction \DimMathAbs { m }
  {
    \Return { \Expand { \dim_abs:n { #1 } } }
  }

\PrgNewFunction \DimMathMax { m m }
  {
    \Return { \Expand { \dim_max:nn { #1 } { #2 } } }
  }

\PrgNewFunction \DimMathMin { m m }
  {
    \Return { \Expand { \dim_min:nn { #1 } { #2 } } }
  }

\PrgNewFunction \DimMathRatio { m m }
  {
    \Return { \Expand { \dim_ratio:nn { #1 } { #2 } } }
  }

\PrgNewFunction \DimNew { M } { \dim_new:N #1 }

\PrgNewFunction \DimConst { M m } { \dim_const:Nn #1 {#2} }

\PrgNewFunction \DimUse { M } { \Return { \Value #1 } }

\PrgNewFunction \DimLog { m } { \dim_log:n { #1 } }

\PrgNewFunction \DimVarLog { M } { \dim_log:N #1 }

\PrgNewFunction \DimShow { m } { \dim_show:n { #1 } }

\PrgNewFunction \DimVarShow { M } { \dim_show:N #1 }

\PrgNewFunction \DimSet { M m }
  {
    \__fun_do_assignment:Nnn #1 { \dim_gset:Nn #1 {#2} } { \dim_set:Nn #1 {#2} }
  }

\PrgNewFunction \DimSetEq { M M }
  {
    \__fun_do_assignment:Nnn #1 { \dim_gset_eq:NN #1 #2 } { \dim_set_eq:NN #1 #2 }
  }

\PrgNewFunction \DimZero { M }
  {
    \__fun_do_assignment:Nnn #1 { \dim_gzero:N #1 } { \dim_zero:N #1 }
  }

\PrgNewFunction \DimZeroNew { M }
  {
    \__fun_do_assignment:Nnn #1 { \dim_gzero_new:N #1 } { \dim_zero_new:N #1 }
  }

\PrgNewFunction \DimAdd { M m }
  {
    \__fun_do_assignment:Nnn #1 { \dim_gadd:Nn #1 {#2} } { \dim_add:Nn #1 {#2} }
  }

\PrgNewFunction \DimSub { M m }
  {
    \__fun_do_assignment:Nnn #1 { \dim_gsub:Nn #1 {#2} } { \dim_sub:Nn #1 {#2} }
  }

\PrgNewFunction \DimStepInline { m m m n }
  {
    \dim_step_inline:nnnn { #1 } { #2 } { #3 } { #4 }
  }

\PrgNewFunction \DimStepVariable { m m m M n }
  {
    \dim_step_variable:nnnNn { #1 } { #2 } { #3 } #4 { #5 }
  }

\PrgNewConditional \DimIfExist { M }
  {
    \dim_if_exist:NTF #1 { \Return { \cTrueBool } } { \Return { \cFalseBool } }
  }

\PrgNewConditional \DimCompare { m N m }
  {
    \dim_compare:nNnTF {#1} #2 {#3}
      { \Return { \cTrueBool } } { \Return { \cFalseBool } }
  }

\PrgNewFunction \DimCase   { m m }     { \dim_case:nn {#1} {#2} }
\PrgNewFunction \DimCaseT  { m m n }   { \dim_case:nnT {#1} {#2} {#3} }
\PrgNewFunction \DimCaseF  { m m n }   { \dim_case:nnF {#1} {#2} {#3} }
\PrgNewFunction \DimCaseTF { m m n n } { \dim_case:nnTF {#1} {#2} {#3} {#4} }

%%% --------------------------------------------------------
%%> \section{Interfaces for Sorting Functions (Sort)}
%%% --------------------------------------------------------

\cs_set_eq:NN \SortReturnSame \sort_return_same:
\cs_set_eq:NN \SortReturnSwapped \sort_return_swapped:

%%% --------------------------------------------------------
%%> \section{Interfaces for Comma Separated Lists (Clist)}
%%% --------------------------------------------------------

\clist_new:N \lTmpaClist   \clist_new:N \lTmpbClist   \clist_new:N \lTmpcClist
\clist_new:N \lTmpiClist   \clist_new:N \lTmpjClist   \clist_new:N \lTmpkClist
\clist_new:N \l@Funx@Clist \clist_new:N \l@Funy@Clist \clist_new:N \l@Funz@Clist

\clist_new:N \gTmpaClist   \clist_new:N \gTmpbClist   \clist_new:N \gTmpcClist
\clist_new:N \gTmpiClist   \clist_new:N \gTmpjClist   \clist_new:N \gTmpkClist
\clist_new:N \g@Funx@Clist \clist_new:N \g@Funy@Clist \clist_new:N \g@Funz@Clist

\clist_set_eq:NN \cEmptyClist \c_empty_clist

\PrgNewFunction \ClistNew { M } { \clist_new:N #1 }

\PrgNewFunction \ClistLog { m } { \clist_log:n { #1 } }

\PrgNewFunction \ClistVarLog { M } { \clist_log:N #1 }

\PrgNewFunction \ClistShow { m } { \clist_show:n { #1 } }

\PrgNewFunction \ClistVarShow { M } { \clist_show:N #1 }

\PrgNewFunction \ClistVarJoin { M m }
  {
    \Expand { \clist_use:Nn #1 { #2 } }
  }

\PrgNewFunction \ClistVarJoinExtended { M m m m }
  {
    \Expand { \clist_use:Nnnn #1 { #2 } { #3 } { #4 } }
  }

\PrgNewFunction \ClistJoin { m m }
  {
    \Expand { \clist_use:nn { #1 } { #2 } }
  }

\PrgNewFunction \ClistJoinExtended { m m m m }
  {
    \Expand { \clist_use:nnnn { #1 } { #2 } { #3 } { #4 } }
  }

\PrgNewFunction \ClistConst { M m } { \clist_const:Nn #1 { #2 } }

\PrgNewFunction \ClistSet { M m }
  {
    \__fun_do_assignment:Nnn #1
      { \clist_gset:Nn #1 {#2} } { \clist_set:Nn #1 {#2} }
  }

\PrgNewFunction \ClistSetEq { M M }
  {
    \__fun_do_assignment:Nnn #1
      { \clist_gset_eq:NN #1 #2 } { \clist_set_eq:NN #1 #2 }
  }

\PrgNewFunction \ClistSetFromSeq { M M }
  {
    \__fun_do_assignment:Nnn #1
      { \clist_gset_from_seq:NN #1 #2 } { \clist_set_from_seq:NN #1 #2 }
  }

\PrgNewFunction \ClistConcat { M M M }
  {
    \__fun_do_assignment:Nnn #1
      { \clist_gconcat:NNN #1 #2 #3 } { \clist_concat:NNN #1 #2 #3 }
  }

\PrgNewFunction \ClistClear { M }
  {
    \__fun_do_assignment:Nnn #1 { \clist_gclear:N #1 } { \clist_clear:N #1 }
  }

\PrgNewFunction \ClistClearNew { M }
  {
    \__fun_do_assignment:Nnn #1 { \clist_gclear_new:N #1 } { \clist_clear_new:N #1 }
  }

\PrgNewFunction \ClistPutLeft { M m }
  {
    \__fun_do_assignment:Nnn #1
      { \clist_gput_left:Nn #1 {#2} } { \clist_put_left:Nn #1 {#2} }
  }

\PrgNewFunction \ClistPutRight { M m }
  {
    \__fun_do_assignment:Nnn #1
      { \clist_gput_right:Nn #1 {#2} } { \clist_put_right:Nn #1 {#2} }
  }

\PrgNewFunction \ClistVarRemoveDuplicates { M }
  {
    \__fun_do_assignment:Nnn #1
      { \clist_gremove_duplicates:N #1 } { \clist_remove_duplicates:N #1 }
  }

\PrgNewFunction \ClistVarRemoveAll { M m }
  {
    \__fun_do_assignment:Nnn #1
      { \clist_gremove_all:Nn #1 {#2} } { \clist_remove_all:Nn #1 {#2} }
  }

\PrgNewFunction \ClistVarReverse { M }
  {
    \__fun_do_assignment:Nnn #1 { \clist_greverse:N #1 } { \clist_reverse:N #1 }
  }

\PrgNewFunction \ClistVarSort { M m }
  {
    \__fun_do_assignment:Nnn #1
      { \clist_gsort:Nn #1 {#2} } { \clist_sort:Nn #1 {#2} }
  }

\PrgNewFunction \ClistCount { m } { \Expand { \clist_count:n { #1 } } }

\PrgNewFunction \ClistVarCount { M } { \Expand { \clist_count:N #1 } }

\PrgNewFunction \ClistGet   { M M }
  {
    \clist_get:NN #1 #2
    \__fun_quark_upgrade_no_value:N #2
  }
\PrgNewFunction \ClistGetT  { M M n }   { \clist_get:NNT #1 #2 {#3} }
\PrgNewFunction \ClistGetF  { M M n }   { \clist_get:NNF #1 #2 {#3} }
\PrgNewFunction \ClistGetTF { M M n n } { \clist_get:NNTF #1 #2 {#3} {#4} }

\PrgNewFunction \ClistPop { M M }
  {
    \__fun_do_assignment:Nnn #1
      { \clist_gpop:NN #1 #2 } { \clist_pop:NN #1 #2 }
    \__fun_quark_upgrade_no_value:N #2
  }
\PrgNewFunction \ClistPopT { M M n }
  {
    \__fun_do_assignment:Nnn #1
      { \clist_gpop:NNT #1 #2 {#3} } { \clist_pop:NNT #1 #2 {#3} }
  }
\PrgNewFunction \ClistPopF { M M n }
  {
    \__fun_do_assignment:Nnn #1
      { \clist_gpop:NNF #1 #2 {#3} } { \clist_pop:NNF #1 #2 {#3} }
  }
\PrgNewFunction \ClistPopTF { M M n n }
  {
    \__fun_do_assignment:Nnn #1
      { \clist_gpop:NNTF #1 #2 {#3} {#4} } { \clist_pop:NNTF #1 #2 {#3} {#4} }
  }

\PrgNewFunction \ClistPush { M m }
  {
    \__fun_do_assignment:Nnn #1
      { \clist_gpush:Nn #1 {#2} } { \clist_push:Nn #1 {#2} }
  }

\PrgNewFunction \ClistItem { m m } { \Expand { \clist_item:nn {#1} {#2} } }

\PrgNewFunction \ClistVarItem { M m } { \Expand { \clist_item:Nn #1 {#2} } }

\PrgNewFunction \ClistRandItem { m } { \Expand { \clist_rand_item:n {#1} } }

\PrgNewFunction \ClistVarRandItem { M } { \Expand { \clist_rand_item:N #1 } }

\PrgNewFunction \ClistMapInline { m n }
  {
    \clist_map_inline:nn {#1} {#2}
  }

\PrgNewFunction \ClistVarMapInline { M n }
  {
    \clist_map_inline:Nn #1 {#2}
  }

\PrgNewFunction \ClistMapVariable { m M n }
  {
    \clist_map_variable:nNn {#1} #2 {#3}
  }

\PrgNewFunction \ClistVarMapVariable { M M n }
  {
    \clist_map_variable:NNn #1 #2 {#3}
  }

\cs_set_eq:NN \ClistMapBreak \clist_map_break:

\PrgNewConditional \ClistIfExist { M }
  {
    \clist_if_exist:NTF #1 { \Return { \cTrueBool } }  { \Return { \cFalseBool } }
  }

\PrgNewConditional \ClistIfEmpty { m }
  {
    \clist_if_empty:nTF {#1} { \Return { \cTrueBool } }  { \Return { \cFalseBool } }
  }

\PrgNewConditional \ClistVarIfEmpty { M }
  {
    \clist_if_empty:NTF #1 { \Return { \cTrueBool } }  { \Return { \cFalseBool } }
  }

\PrgNewConditional \ClistIfIn { m m }
  {
    \clist_if_in:nnTF {#1} {#2}
      { \Return { \cTrueBool } }  { \Return { \cFalseBool } }
  }

\PrgNewConditional \ClistVarIfIn { M m }
  {
    \clist_if_in:NnTF #1 {#2}
      { \Return { \cTrueBool } }  { \Return { \cFalseBool } }
  }

%%% --------------------------------------------------------
%%> \section{Interfaces for Sequences and Stacks (Seq)}
%%% --------------------------------------------------------

\seq_new:N \lTmpaSeq   \seq_new:N \lTmpbSeq   \seq_new:N \lTmpcSeq
\seq_new:N \lTmpiSeq   \seq_new:N \lTmpjSeq   \seq_new:N \lTmpkSeq
\seq_new:N \l@Funx@Seq \seq_new:N \l@Funy@Seq \seq_new:N \l@Funz@Seq

\seq_new:N \gTmpaSeq   \seq_new:N \gTmpbSeq   \seq_new:N \gTmpcSeq
\seq_new:N \gTmpiSeq   \seq_new:N \gTmpjSeq   \seq_new:N \gTmpkSeq
\seq_new:N \g@Funx@Seq \seq_new:N \g@Funy@Seq \seq_new:N \g@Funz@Seq

\seq_set_eq:NN \cEmptySeq \c_empty_seq

\PrgNewFunction \SeqNew { M } { \seq_new:N #1 }

\PrgNewFunction \SeqVarLog { M } { \seq_log:N #1 }

\PrgNewFunction \SeqVarShow { M } { \seq_show:N #1 }

\PrgNewFunction \SeqVarJoin { M m }
  {
    \Expand { \seq_use:Nn #1 { #2 } }
  }

\PrgNewFunction \SeqVarJoinExtended { M m m m }
  {
    \Expand { \seq_use:Nnnn #1 { #2 } { #3 } { #4 } }
  }

\PrgNewFunction \SeqJoin { m m }
  {
    \Expand { \seq_use:nn { #1 } { #2 } }
  }

\PrgNewFunction \SeqJoinExtended { m m m m }
  {
    \Expand { \seq_use:nnnn { #1 } { #2 } { #3 } { #4 } }
  }

\PrgNewFunction \SeqConstFromClist { M m } { \seq_const_from_clist:Nn #1 { #2 } }

\PrgNewFunction \SeqSetFromClist { M m }
  {
    \__fun_do_assignment:Nnn #1
      { \seq_gset_from_clist:Nn #1 {#2} } { \seq_set_from_clist:Nn #1 {#2} }
  }

\PrgNewFunction \SeqSetEq { M M }
  {
    \__fun_do_assignment:Nnn #1
      { \seq_gset_eq:NN #1 #2 } { \seq_set_eq:NN #1 #2 }
  }

\PrgNewFunction \SeqSetSplit { M m m }
  {
    \__fun_do_assignment:Nnn #1
      { \seq_gset_split:Nnn #1 {#2} {#3} } { \seq_set_split:Nnn #1 {#2} {#3} }
  }

\PrgNewFunction \SeqConcat { M M M }
  {
    \__fun_do_assignment:Nnn #1
      { \seq_gconcat:NNN #1 #2 #3 } { \seq_concat:NNN #1 #2 #3 }
  }

\PrgNewFunction \SeqClear { M }
  {
    \__fun_do_assignment:Nnn #1 { \seq_gclear:N #1 } { \seq_clear:N #1 }
  }

\PrgNewFunction \SeqClearNew { M }
  {
    \__fun_do_assignment:Nnn #1 { \seq_gclear_new:N #1 } { \seq_clear_new:N #1 }
  }

\PrgNewFunction \SeqPutLeft { M m }
  {
    \__fun_do_assignment:Nnn #1
      { \seq_gput_left:Nn #1 {#2} } { \seq_put_left:Nn #1 {#2} }
  }

\PrgNewFunction \SeqPutRight { M m }
  {
    \__fun_do_assignment:Nnn #1
      { \seq_gput_right:Nn #1 {#2} } { \seq_put_right:Nn #1 {#2} }
  }

\PrgNewFunction \SeqVarRemoveDuplicates { M }
  {
    \__fun_do_assignment:Nnn #1
      { \seq_gremove_duplicates:N #1 } { \seq_remove_duplicates:N #1 }
  }

\PrgNewFunction \SeqVarRemoveAll { M m }
  {
    \__fun_do_assignment:Nnn #1
      { \seq_gremove_all:Nn #1 {#2} } { \seq_remove_all:Nn #1 {#2} }
  }

\PrgNewFunction \SeqVarReverse { M }
  {
    \__fun_do_assignment:Nnn #1 { \seq_greverse:N #1 } { \seq_reverse:N #1 }
  }

\PrgNewFunction \SeqVarSort { M m }
  {
    \__fun_do_assignment:Nnn #1
      { \seq_gsort:Nn #1 {#2} } { \seq_sort:Nn #1 {#2} }
  }

\PrgNewFunction \SeqVarCount { M } { \Expand { \seq_count:N #1 } }

\PrgNewFunction \SeqGet { M M }
  {
    \seq_get:NN #1 #2
    \__fun_quark_upgrade_no_value:N #2
  }
\PrgNewFunction \SeqGetT  { M M n }   { \seq_get:NNT #1 #2 {#3} }
\PrgNewFunction \SeqGetF  { M M n }   { \seq_get:NNF #1 #2 {#3} }
\PrgNewFunction \SeqGetTF { M M n n } { \seq_get:NNTF #1 #2 {#3} {#4} }

\PrgNewFunction \SeqPop { M M }
  {
    \__fun_do_assignment:Nnn #1
      { \seq_gpop:NN #1 #2 } { \seq_pop:NN #1 #2 }
    \__fun_quark_upgrade_no_value:N #2
  }
\PrgNewFunction \SeqPopT { M M n }
  {
    \__fun_do_assignment:Nnn #1
      { \seq_gpop:NNT #1 #2 {#3} } { \seq_pop:NNT #1 #2 {#3} }
  }
\PrgNewFunction \SeqPopF { M M n }
  {
    \__fun_do_assignment:Nnn #1
      { \seq_gpop:NNF #1 #2 {#3} } { \seq_pop:NNF #1 #2 {#3} }
  }
\PrgNewFunction \SeqPopTF { M M n n }
  {
    \__fun_do_assignment:Nnn #1
      { \seq_gpop:NNTF #1 #2 {#3} {#4} } { \seq_pop:NNTF #1 #2 {#3} {#4} }
  }

\PrgNewFunction \SeqPush { M m }
  {
    \__fun_do_assignment:Nnn #1
      { \seq_gpush:Nn #1 {#2} } { \seq_push:Nn #1 {#2} }
  }

\PrgNewFunction \SeqGetLeft { M M }
  {
    \seq_get_left:NN #1 #2
    \__fun_quark_upgrade_no_value:N #2
  }
\PrgNewFunction \SeqGetLeftT  { M M n }   { \seq_get_left:NNT #1 #2 {#3} }
\PrgNewFunction \SeqGetLeftF  { M M n }   { \seq_get_left:NNF #1 #2 {#3} }
\PrgNewFunction \SeqGetLeftTF { M M n n } { \seq_get_left:NNTF #1 #2 {#3} {#4} }

\PrgNewFunction \SeqGetRight { M M }
  {
    \seq_get_right:NN #1 #2
    \__fun_quark_upgrade_no_value:N #2
  }
\PrgNewFunction \SeqGetRightT  { M M n }   { \seq_get_right:NNT #1 #2 {#3} }
\PrgNewFunction \SeqGetRightF  { M M n }   { \seq_get_right:NNF #1 #2 {#3} }
\PrgNewFunction \SeqGetRightTF { M M n n } { \seq_get_right:NNTF #1 #2 {#3} {#4} }

\PrgNewFunction \SeqPopLeft { M M }
  {
    \__fun_do_assignment:Nnn #1
      { \seq_gpop_left:NN #1 #2 } { \seq_pop_left:NN #1 #2 }
    \__fun_quark_upgrade_no_value:N #2
  }
\PrgNewFunction \SeqPopLeftT { M M n }
  {
    \__fun_do_assignment:Nnn #1
      { \seq_gpop_left:NNT #1 #2 {#3} } { \seq_pop_left:NNT #1 #2 {#3} }
  }
\PrgNewFunction \SeqPopLeftF { M M n }
  {
    \__fun_do_assignment:Nnn #1
      { \seq_gpop_left:NNF #1 #2 {#3} } { \seq_pop_left:NNF #1 #2 {#3} }
  }
\PrgNewFunction \SeqPopLeftTF { M M n n }
  {
    \__fun_do_assignment:Nnn #1
      { \seq_gpop_left:NNTF #1 #2 {#3} {#4} }
      { \seq_pop_left:NNTF #1 #2 {#3} {#4} }
  }

\PrgNewFunction \SeqPopRight { M M }
  {
    \__fun_do_assignment:Nnn #1
      { \seq_gpop_right:NN #1 #2 } { \seq_pop_right:NN #1 #2 }
    \__fun_quark_upgrade_no_value:N #2
  }
\PrgNewFunction \SeqPopRightT { M M n }
  {
    \__fun_do_assignment:Nnn #1
      { \seq_gpop_right:NNT #1 #2 {#3} } { \seq_pop_right:NNT #1 #2 {#3} }
  }
\PrgNewFunction \SeqPopRightF { M M n }
  {
    \__fun_do_assignment:Nnn #1
      { \seq_gpop_right:NNF #1 #2 {#3} } { \seq_pop_right:NNF #1 #2 {#3} }
  }
\PrgNewFunction \SeqPopRightTF { M M n n }
  {
    \__fun_do_assignment:Nnn #1
      { \seq_gpop_right:NNTF #1 #2 {#3} {#4} }
      { \seq_pop_right:NNTF #1 #2 {#3} {#4} }
  }

\PrgNewFunction \SeqVarItem { M m } { \Expand { \seq_item:Nn #1 {#2} } }

\PrgNewFunction \SeqVarRandItem { M } { \Expand { \seq_rand_item:N #1 } }

\PrgNewFunction \SeqVarMapInline { M n }
  {
    \seq_map_inline:Nn #1 {#2}
  }

\PrgNewFunction \SeqVarMapVariable { M M n }
  {
    \seq_map_variable:NNn #1 #2 {#3}
  }

\cs_set_eq:NN \SeqMapBreak \seq_map_break:

\PrgNewConditional \SeqIfExist { M }
  {
    \seq_if_exist:NTF #1 { \Return { \cTrueBool } }  { \Return { \cFalseBool } }
  }

\PrgNewConditional \SeqVarIfEmpty { M }
  {
    \seq_if_empty:NTF #1 { \Return { \cTrueBool } }  { \Return { \cFalseBool } }
  }

\PrgNewConditional \SeqVarIfIn { M m }
  {
    \seq_if_in:NnTF #1 {#2}
      { \Return { \cTrueBool } }  { \Return { \cFalseBool } }
  }

%%% --------------------------------------------------------
%%> \section{Interfaces for Property Lists (Prop)}
%%% --------------------------------------------------------

\prop_new:N \lTmpaProp   \prop_new:N \lTmpbProp   \prop_new:N \lTmpcProp
\prop_new:N \lTmpiProp   \prop_new:N \lTmpjProp   \prop_new:N \lTmpkProp
\prop_new:N \l@Funx@Prop \prop_new:N \l@Funy@Prop \prop_new:N \l@Funz@Prop

\prop_new:N \gTmpaProp   \prop_new:N \gTmpbProp   \prop_new:N \gTmpcProp
\prop_new:N \gTmpiProp   \prop_new:N \gTmpjProp   \prop_new:N \gTmpkProp
\prop_new:N \g@Funx@Prop \prop_new:N \g@Funy@Prop \prop_new:N \g@Funz@Prop

\prop_set_eq:NN \cEmptyProp \c_empty_prop

\PrgNewFunction \PropNew { M } { \prop_new:N #1 }

\PrgNewFunction \PropVarLog { M } { \prop_log:N #1 }

\PrgNewFunction \PropVarShow { M } { \prop_show:N #1 }

\PrgNewFunction \PropConstFromKeyval { M m }
  { \prop_const_from_keyval:Nn #1 { #2 } }

\PrgNewFunction \PropSetFromKeyval { M m }
  {
    \__fun_do_assignment:Nnn #1
      { \prop_gset_from_keyval:Nn #1 {#2} } { \prop_set_from_keyval:Nn #1 {#2} }
  }

\PrgNewFunction \PropSetEq { M M }
  {
    \__fun_do_assignment:Nnn #1
      { \prop_gset_eq:NN #1 #2 } { \prop_set_eq:NN #1 #2 }
  }

\PrgNewFunction \PropClear { M }
  {
    \__fun_do_assignment:Nnn #1 { \prop_gclear:N #1 } { \prop_clear:N #1 }
  }

\PrgNewFunction \PropClearNew { M }
  {
    \__fun_do_assignment:Nnn #1 { \prop_gclear_new:N #1 } { \prop_clear_new:N #1 }
  }

\PrgNewFunction \PropConcat { M M M }
  {
    \__fun_do_assignment:Nnn #1
      { \prop_gconcat:NNN #1 #2 #3 } { \prop_concat:NNN #1 #2 #3 }
  }

\PrgNewFunction \PropPut { M m m }
  {
    \__fun_do_assignment:Nnn #1
      { \prop_gput:Nnn #1 {#2} {#3} } { \prop_put:Nnn #1 {#2} {#3} }
  }

\PrgNewFunction \PropPutIfNew { M m m }
  {
    \__fun_do_assignment:Nnn #1
      { \prop_gput_if_new:Nnn #1 {#2} {#3} } { \prop_put_if_new:Nnn #1 {#2} {#3} }
  }

\PrgNewFunction \PropPutFromKeyval { M m }
  {
    \__fun_do_assignment:Nnn #1
      { \prop_gput_from_keyval:Nn #1 {#2} } { \prop_put_from_keyval:Nn #1 {#2} }
  }

\PrgNewFunction \PropVarRemove { M m }
  {
    \__fun_do_assignment:Nnn #1
      { \prop_gremove:Nn #1 {#2} } { \prop_remove:Nn #1 {#2} }
  }

\PrgNewFunction \PropVarCount { M } { \Expand { \prop_count:N #1 } }

\PrgNewFunction \PropVarItem { M m } { \Expand { \prop_item:Nn #1 {#2} } }

\PrgNewFunction \PropToKeyval { M } { \Expand { \prop_to_keyval:N #1 } }

\PrgNewFunction \PropGet { M m M }
  {
    \prop_get:NnN #1 {#2} #3
    \__fun_quark_upgrade_no_value:N #3
  }
\PrgNewFunction \PropGetT  { M m M n }   { \prop_get:NnNT #1 {#2} #3 {#4} }
\PrgNewFunction \PropGetF  { M m M n }   { \prop_get:NnNF #1 {#2} #3 {#4} }
\PrgNewFunction \PropGetTF { M m M n n } { \prop_get:NnNTF #1 {#2} #3 {#4} {#5} }

\PrgNewFunction \PropPop { M m M }
  {
    \__fun_do_assignment:Nnn #1
      { \prop_gpop:NnN #1 {#2} #3 } { \prop_pop:NnN #1 {#2} #3 }
    \__fun_quark_upgrade_no_value:N #3
  }
\PrgNewFunction \PropPopT { M m M n }
  {
    \__fun_do_assignment:Nnn #1
      { \prop_gpop:NnNT #1 {#2} #3 {#4} } { \prop_pop:NnNT #1 {#2} #3 {#4} }
  }
\PrgNewFunction \PropPopF { M m M n }
  {
    \__fun_do_assignment:Nnn #1
      { \prop_gpop:NnNF #1 {#2} #3 {#4} } { \prop_pop:NnNF #1 {#2} #3 {#4} }
  }
\PrgNewFunction \PropPopTF { M m M n n }
  {
    \__fun_do_assignment:Nnn #1
      { \prop_gpop:NnNTF #1 {#2} #3 {#4} {#5} }
      { \prop_pop:NnNTF #1 {#2} #3 {#4} {#5} }
  }

\PrgNewFunction \PropVarMapInline { M n }
  {
    \prop_map_inline:Nn #1 {#2}
  }

\cs_set_eq:NN \PropMapBreak \prop_map_break:

\PrgNewConditional \PropIfExist { M }
  {
    \prop_if_exist:NTF #1 { \Return { \cTrueBool } }  { \Return { \cFalseBool } }
  }

\PrgNewConditional \PropVarIfEmpty { M }
  {
    \prop_if_empty:NTF #1 { \Return { \cTrueBool } }  { \Return { \cFalseBool } }
  }

\PrgNewConditional \PropVarIfIn { M m }
  {
    \prop_if_in:NnTF #1 {#2}
      { \Return { \cTrueBool } }  { \Return { \cFalseBool } }
  }

%%% --------------------------------------------------------
%%> \section{Interfaces for Token Manipulation (Token)}
%%% --------------------------------------------------------

\PrgNewFunction \CharLowercase { M }
  {
    \Expand { \char_lowercase:N #1 }
  }

\PrgNewFunction \CharUppercase { M }
  {
    \Expand { \char_uppercase:N #1 }
  }

\PrgNewFunction \CharTitlecase { M }
  {
    \Expand { \char_titlecase:N #1 }
  }

\PrgNewFunction \CharFoldcase { M }
  {
    \Expand { \char_foldcase:N #1 }
  }

\PrgNewFunction \CharStrLowercase { M }
  {
    \Expand { \char_str_lowercase:N #1 }
  }

\PrgNewFunction \CharStrUppercase { M }
  {
    \Expand { \char_str_uppercase:N #1 }
  }

\PrgNewFunction \CharStrTitlecase { M }
  {
    \Expand { \char_str_titlecase:N #1 }
  }

\PrgNewFunction \CharStrFoldcase { M }
  {
    \Expand { \char_str_foldcase:N #1 }
  }

\PrgNewFunction \CharSetLccode { m m }
  {
    \char_set_lccode:nn {#1} {#2}
  }

\PrgNewFunction \CharValueLccode { m }
  {
    \Expand { \char_value_lccode:n {#1} }
  }

\PrgNewFunction \CharSetUccode { m m }
  {
    \char_set_uccode:nn {#1} {#2}
  }

\PrgNewFunction \CharValueUccode { m }
  {
    \Expand { \char_value_uccode:n {#1} }
  }

%%% --------------------------------------------------------
%%> \section{Interfaces for Text Processing (Text)}
%%% --------------------------------------------------------

\PrgNewFunction \TextExpand { m }
  {
    \Expand { \text_expand:n {#1} }
  }

\PrgNewFunction \TextLowercase { m }
  {
    \Expand { \text_lowercase:n {#1} }
  }

\PrgNewFunction \TextUppercase { m }
  {
    \Expand { \text_uppercase:n {#1} }
  }

\PrgNewFunction \TextTitlecase { m }
  {
    \Expand { \text_titlecase:n {#1} }
  }

\PrgNewFunction \TextTitlecaseFirst { m }
  {
    \Expand { \text_titlecase_first:n {#1} }
  }

\PrgNewFunction \TextLangLowercase { m m }
  {
    \Expand { \text_lowercase:nn {#1} {#2} }
  }

\PrgNewFunction \TextLangUppercase { m m }
  {
    \Expand { \text_uppercase:nn {#1} {#2} }
  }

\PrgNewFunction \TextLangTitlecase { m m }
  {
    \Expand { \text_titlecase:nn {#1} {#2} }
  }

\PrgNewFunction \TextLangTitlecaseFirst { m m }
  {
    \Expand { \text_titlecase_first:nn {#1} {#2} }
  }

%%% --------------------------------------------------------
%%> \section{Interfaces for Files (File)}
%%% --------------------------------------------------------

\msg_new:nnn { functional } { file-not-found } { File ~ "#1" ~ not ~ found! }

\PrgNewFunction \FileInput { m }
  {
    \file_get:nnN {#1} {} \l@FunxTl
    \quark_if_no_value:NTF \l@FunxTl
      { \msg_error:nnn { functional } { file-not-found } { #1 } }
      { \TlUse \l@FunxTl }
  }

\PrgNewFunction \FileIfExistInput { m }
  {
    \file_get:nnN {#1} {} \l@FunxTl
    \quark_if_no_value:NF \l@FunxTl { \TlUse \l@FunxTl }
  }

\PrgNewFunction \FileIfExistInputF { m n }
  {
    \file_get:nnN {#1} {} \l@FunxTl
    \quark_if_no_value:NTF \l@FunxTl { #2 } { \TlUse \l@FunxTl }
  }

\cs_set_eq:NN \FileInputStop \file_input_stop:

\PrgNewFunction \FileGet { m m M }
  {
    \file_get:nnN {#1} {#2} #3
    \__fun_quark_upgrade_no_value:N #3
  }

\PrgNewFunction \FileGetT { m m M n }
  {
    \file_get:nnNT {#1} {#2} #3 {#4}
  }

\PrgNewFunction \FileGetF { m m M n }
  {
    \file_get:nnNF {#1} {#2} #3 {#4}
  }

\PrgNewFunction \FileGetTF { m m M n n }
  {
    \file_get:nnNTF {#1} {#2} #3 {#4} {#5}
  }

\PrgNewConditional \FileIfExist { m }
  {
    \file_if_exist:nTF {#1} { \Return { \cTrueBool } }  { \Return { \cFalseBool } }
  }

%%% --------------------------------------------------------
%%> \section{Interfaces for Quarks (Quark)}
%%% --------------------------------------------------------

\quark_new:N \qNoValue

\cs_new_protected:Npn \__fun_quark_upgrade_no_value:N #1
  {
    \quark_if_no_value:NT #1 { \tl_set_eq:NN #1 \qNoValue }
  }

\PrgNewConditional \QuarkVarIfNoValue { M }
  {
    \tl_if_eq:NNTF \qNoValue #1
      { \Return { \cTrueBool } }  { \Return { \cFalseBool } }
  }

%%% --------------------------------------------------------
%%> \section{Interfaces to Legacy Concepts (Legacy)}
%%% --------------------------------------------------------

\PrgNewConditional \LegacyIf { m }
  {
    \legacy_if:nTF {#1} { \Return { \cTrueBool } }  { \Return { \cFalseBool } }
  }

\PrgNewFunction \LegacyIfSetTrue { m }
  {
    \__fun_do_assignment:Nnn \c@name
      { \legacy_if_gset_true:n {#1} } { \legacy_if_set_true:n {#1} }
  }

\PrgNewFunction \LegacyIfSetFalse { m }
  {
    \__fun_do_assignment:Nnn \c@name
      { \legacy_if_gset_false:n {#1} } { \legacy_if_set_false:n {#1} }
  }

\PrgNewFunction \LegacyIfSet { m m }
  {
    \__fun_do_assignment:Nnn \c@name
      { \legacy_if_gset:nn {#1} {#2} } { \legacy_if_set:nn {#1} {#2} }
  }
