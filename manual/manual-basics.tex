% -*- coding: utf-8 -*-
% !TEX program = lualatex
\documentclass[oneside]{book}

\input{manual.sty}
\CodeHigh{lite}

\begin{document}

\chapter{Basic Definitions (\texttt{Prg} and \texttt{Use})}

\section{DeÔ¨Åning Functions and Conditionals}

\begin{function}{\PrgNewFunction}
\begin{syntax}
\cs{PrgNewFunction} \meta{function} \Arg{argument specification} \Arg{code}
\end{syntax}
Creates protected \meta{function} for evaluating the \meta{code}.
Within the \meta{code}, the parameters (\verb|#1|, \verb|#2|,
\emph{etc.}) will be replaced by those absorbed by the function.
The returned value \emph{must} be passed with \cs{Result} function.
The definition is global and an error results if the
\meta{function} is already defined.\par
The \Arg{argument specification} in a list of letters,
where each letter is one of the following argument specifiers
(nearly all of them are \texttt{M} or \texttt{m} for functions provided by this package):\par
{\centering\begin{tabular}{ll}
%\hline
  \texttt{M} & single-token argument, which will be manipulated first \\
  \texttt{m} & multi-token argument, which will be manipulated first \\
  \texttt{N} & single-token argument, which will not be manipulated first \\
  \texttt{n} & multi-token argument, which will not be manipulated first \\
%\hline
\end{tabular}\par}
The argument manipulation for argument type \texttt{M} or \texttt{m}
is: if the argument starts with a function defined with \cs{PrgNewFunction},
the argument will be evaluated and replaced with the returned value.
\end{function}

\begin{function}{\PrgNewConditional}
\begin{syntax}
\cs{PrgNewConditional} \meta{function} \Arg{argument specification} \Arg{code}
\end{syntax}
Creates protected conditional \meta{function} for evaluating the \meta{code}.
The returned value of the \meta{function} \emph{must} be either \verb!\cTrueBool!
or \verb!\cFalseBool! and be passed with \cs{Result} function..
The definition is global and an error results if the \meta{function} is already defined.
\par
Assume the \meta{function} is \verb!\FooIfBar!, then another function \verb!\FooIfBarTF!
will be created at the same time. \verb!\FooIfBarTF! function has two extra arguments
which are \Arg{true code} and \Arg{false code}.\par
\end{function}

\begin{function}{\Result}
\begin{syntax}
\cs{Result} \Arg{tokens}
\end{syntax}
Appends \meta{tokens} to \verb!\gResultTl!, which holds the returned value of current function.
This function is normally used in the \meta{code} of \cs{PrgNewFunction} and \cs{PrgNewConditional}.
\end{function}

\section{Expanding and Using Tokens}

\begin{function}{\Name}
\begin{syntax}
\cs{Name} \Arg{control sequence name}
\end{syntax}
Expands the \meta{control sequence name} until only characters
remain, then converts this into a control sequence and returns it.
The \meta{control sequence name} must consist of character tokens %,
%typically a mixture of category code $10$ (space), $11$ (letter) and $12$ (other).
when exhaustively expanded.%
%\begin{texnote}
%Protected macros that appear in a \texttt{c}-type argument are
%expanded despite being protected; \cs{exp_not:n} also has no
%effect.  An internal error occurs if non-characters or active
%characters remain after full expansion, as the conversion to a
%control sequence is not possible.
%\end{texnote}
\end{function}

\begin{function}{\Value}
\begin{syntax}
\cs{Value} \meta{variable}
\end{syntax}
Recovers the content of a \meta{variable} and returns the value.
An error is raised if the variable does not exist or if it is invalid.
Note that it is the same as \cs{TlUse} for \meta{tl var}, or \cs{IntUse} for \meta{int var}.
\end{function}

\begin{function}{\Expand}
\begin{syntax}
\cs{Expand} \Arg{tokens}
\end{syntax}
Expands the \meta{tokens} exhaustively and returns the result.
\end{function}

\begin{function}{\ExpNot}
\begin{syntax}
\cs{ExpNot} \Arg{tokens}
\end{syntax}
Prevents expansion of the \meta{tokens} inside the argument of \cs{Expand} function.
The argument of \cs{ExpNot} \emph{must} be surrounded by braces.
%\begin{texnote}
%This is the \eTeX{} \tn{unexpanded} primitive.  In an
%|x|-expanding definition (\cs{cs_new:Npx}), \cs{exp_not:n}~|{#1}|
%is equivalent to |##1| rather than to~|#1|, namely it inserts the
%two characters |#| and~|1|.  In an |e|-type argument
%\cs{exp_not:n}~|{#}| is equivalent to |#|, namely it inserts the
%character~|#|.
%\end{texnote}
\end{function}

\begin{function}{\ExpValue}
\begin{syntax}
\cs{ExpValue} \meta{variable}
\end{syntax}
Recovers the content of the \meta{variable}, then prevents expansion
of this material inside the argument of \cs{Expand} function.
\end{function}

\begin{function}{\UseOne,\GobbleOne}
\begin{syntax}
\cs{UseOne} \Arg{argument}
\cs{GobbleOne} \Arg{argument}
\end{syntax}
The function \cs{UseOne} absorbs one argument and returns it.
%\begin{texnote}
%The \cs{UseOne} function is equivalent to \LaTeXe{}'s \tn{@firstofone}.
%\end{texnote}
\cs{GobbleOne} absorbs one argument and returns nothing.
%\begin{texnote}
%These are equivalent to \LaTeXe{}'s \tn{@gobble}, \tn{@gobbbletwo},
%\emph{etc.}
%\end{texnote}
For example
\begin{demohigh}
\UseOne{abc}\GobbleOne{ijk}\UseOne{xyz}
\end{demohigh}
\end{function}

\begin{function}{\UseGobble,\GobbleUse}
\begin{syntax}
\cs{UseGobble} \Arg{arg_1} \Arg{arg_2}
\cs{GobbleUse} \Arg{arg_1} \Arg{arg_2}
\end{syntax}
These functions absorb two arguments.
The function \cs{UseGobble} discards the second argument,
and returns the content of the first argument.
\cs{GobbleUse} discards the first argument,
and returns the content of the second argument.
%\begin{texnote}
%These are equivalent to \LaTeXe{}'s \tn{@firstoftwo} and
%\tn{@secondoftwo}.
%\end{texnote}
For example
\begin{demohigh}
\UseGobble{abc}{uvw}\GobbleUse{abc}{uvw}
\end{demohigh}
\end{function}

\end{document}
