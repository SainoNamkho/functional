% -*- coding: utf-8 -*-
% !TEX program = lualatex
\documentclass[oneside]{book}

\input{manual.sty}
\CodeHigh{lite}

\begin{document}

\chapter{Strings (\texttt{Str})}

\section{Constant and Scratch Strings}

\begin{variable}{\cAmpersandStr,\cAtsignStr,\cBackslashStr,\cLeftBraceStr,\cRightBraceStr,
\cCircumflexStr,\cColonStr,\cDollarStr,\cHashStr,\cPercentStr,\cTildeStr,\cUnderscoreStr,\cZeroStr}
Constant strings, containing a single character token, with category code $12$.
\end{variable}

\begin{variable}{\lTmpaStr,\lTmpbStr,\lTmpcStr,\lTmpiStr,\lTmpjStr,\lTmpkStr}
Scratch strings for local assignment. These are never used by
the \verb!functional! package, and so are safe for use with any
function. However, they may be overwritten by other
code and so should only be used for short-term storage.
\end{variable}

\begin{variable}{\gTmpaStr,\gTmpbStr,\gTmpcStr,\gTmpiStr,\gTmpjStr,\gTmpkStr}
Scratch strings for global assignment. These are never used by
the \verb!functional! package, and so are safe for use with any
function. However, they may be overwritten by other
code and so should only be used for short-term storage.
\end{variable}

\section{Creating and Using Strings}

\begin{function}{\StrNew}
\begin{syntax}
\cs{StrNew} \meta{str var}
\end{syntax}
Creates a new \meta{str var} or raises an error if the name is
already taken. The declaration is global. The \meta{str var} is
initially empty.
\end{function}

\begin{function}{\StrConst}
\begin{syntax}
\cs{StrConst} \meta{str var} \Arg{token list}
\end{syntax}
Creates a new constant \meta{str var} or raises an error if the name
is already taken.  The value of the \meta{str var} is set
globally to the \meta{token list}, converted to a string.
\end{function}

\begin{function}{\StrUse}
\begin{syntax}
\cs{StrUse} \meta{str var}
\end{syntax}
Recovers the content of a \meta{str var} and returns the value.
An error is raised if the variable
does not exist or if it is invalid. Note that it is possible to use
a \meta{str} directly without an accessor function.
\end{function}

\section{Viewing Strings}

\begin{function}{\StrLog}
\begin{syntax}
\cs{StrLog} \Arg{token list}
\end{syntax}
Writes \meta{token list} in the log file.
\end{function}

\begin{function}{\StrVarLog}
\begin{syntax}
\cs{StrVarLog} \meta{str var}
\end{syntax}
Writes the content of the \meta{str var} in the log file.
For example
\begin{codehigh}
\StrSet \lTmpiStr {1234\abcd5678}
\StrVarLog \lTmpiStr
\end{codehigh}
\end{function}

\begin{function}{\StrShow}
\begin{syntax}
\cs{StrShow} \Arg{token list}
\end{syntax}
Displays \meta{token list} on the terminal.
\end{function}

\begin{function}{\StrVarShow}
\begin{syntax}
\cs{StrVarShow} \meta{str var}
\end{syntax}
Displays the content of the \meta{str var} on the terminal.
\end{function}

\section{Setting String Variables}

\begin{function}{\StrSet}
\begin{syntax}
\cs{StrSet} \meta{str var} \Arg{token list}
\end{syntax}
Converts the \meta{token list} to a \meta{string}, and stores the
result in \meta{str var}. For example
\begin{demohigh}
\StrSet \lTmpiStr {\IntMathMult{4}{5}}
\StrUse \lTmpiStr
\end{demohigh}
\end{function}

\begin{function}{\StrSetEq}
\begin{syntax}
\cs{StrSetEq} \meta{str var_1} \meta{str var_2}
\end{syntax}
Sets the content of \meta{str var_1} equal to that of
\meta{str var_2}.
\end{function}

\begin{function}{\StrClear}
\begin{syntax}
\cs{StrClear} \meta{str var}
\end{syntax}
Clears the content of the \meta{str var}. For example
\begin{demohigh}
\StrSet \lTmpjStr {One}
\StrClear \lTmpjStr
\StrSet \lTmpjStr {Two}
\StrUse \lTmpjStr
\end{demohigh}
\end{function}

\begin{function}{\StrClearNew}
\begin{syntax}
\cs{StrClearNew} \meta{str var}
\end{syntax}
Ensures that the \meta{str var} exists globally by applying
\cs{StrNew} if necessary, then applies \cs{StrClear} to leave
the \meta{str var} empty.
\end{function}

\begin{function}{\StrConcat}
\begin{syntax}
\cs{StrConcat} \meta{str var_1} \meta{str var_2} \meta{str var_3}
\end{syntax}
Concatenates the content of \meta{str var_2} and \meta{str var_3}
together and saves the result in \meta{str var_1}. The \meta{str var_2}
is placed at the left side of the new string variable.
The \meta{str var_2} and \meta{str var_3} must indeed be strings, as
this function does not convert their contents to a string.
\end{function}

\begin{function}{\StrPutLeft}
\begin{syntax}
\cs{StrPutLeft} \meta{str var} \Arg{token list}
\end{syntax}
Converts the \meta{token list} to a \meta{string}, and prepends the
result to \meta{str var}.  The current contents of the \meta{str
var} are not automatically converted to a string. For example
\begin{demohigh}
\StrSet \lTmpkStr {Functional}
\StrPutLeft \lTmpkStr {Hello}
\StrUse \lTmpkStr
\end{demohigh}
\end{function}

\begin{function}{\StrPutRight}
\begin{syntax}
\cs{StrPutRight} \meta{str var} \Arg{token list}
\end{syntax}
Converts the \meta{token list} to a \meta{string}, and appends the
result to \meta{str var}.  The current contents of the \meta{str
var} are not automatically converted to a string. For example
\begin{demohigh}
\StrSet \lTmpkStr {Functional}
\StrPutRight \lTmpkStr {World}
\StrUse \lTmpkStr
\end{demohigh}
\end{function}

\section{Modifying String Variables}

\begin{function}{\StrVarReplaceOnce}
\begin{syntax}
\cs{StrVarReplaceOnce} \meta{str var} \Arg{old} \Arg{new}
\end{syntax}
Converts the \meta{old} and \meta{new} token lists to strings, then
replaces the first (leftmost) occurrence of \meta{old string} in the
\meta{str var} with \meta{new string}.
\end{function}

\begin{function}{\StrVarReplaceAll}
\begin{syntax}
\cs{StrVarReplaceAll} \meta{str var} \Arg{old} \Arg{new}
\end{syntax}
Converts the \meta{old} and \meta{new} token lists to strings, then
replaces all occurrences of \meta{old string} in the
\meta{str var} with \meta{new string}.
As this function
operates from left to right, the pattern \meta{old string}
may remain after the replacement.
\end{function}

\begin{function}{\StrVarRemoveOnce}
\begin{syntax}
\cs{StrVarRemoveOnce} \meta{str var} \Arg{token list}
\end{syntax}
Converts the \meta{token list} to a \meta{string} then
removes the first (leftmost) occurrence of \meta{string} from the
\meta{str var}.
\end{function}

\begin{function}{\StrVarRemoveAll}
\begin{syntax}
\cs{StrVarRemoveAll} \meta{str var} \Arg{token list}
\end{syntax}
Converts the \meta{token list} to a \meta{string} then
removes all occurrences of \meta{string} from the \meta{str var}.
As this function operates from left to right,
the pattern \meta{string} may remain after the removal, for instance,
\begin{demohigh}
\StrSet \lTmpaStr {abbccd}
\StrVarRemoveAll \lTmpaStr {bc}
\TlUse \lTmpaStr
\end{demohigh}
\end{function}

\section{Working with the Content of Strings}

\begin{function}{\StrCount}
\begin{syntax}
\cs{StrCount} \Arg{token list}
\end{syntax}
Returns the number of characters in the string representation of \meta{token list},
as an integer denotation. All characters including spaces are counted.
\par
Due to naming conflict, you need to use \cs{StrSize} instead of \cs{StrCount}
if you want to use \verb!functional! package together with \verb!xstring! package.
\end{function}

\begin{function}{\StVarCount}
\begin{syntax}
\cs{StrVarCount} \meta{tl var}
\end{syntax}
Returns the number of characters in the string representation of the \meta{tl var},
as an integer denotation. All characters including spaces are counted.
\end{function}

\begin{function}{\StrHead}
\begin{syntax}
\cs{StrHead} \Arg{token list}
\end{syntax}
Converts the \meta{token list} into a \meta{string}.
The first character in the \meta{string} is then returned,
with category code \enquote{other}. If the first character is a space,
it returns a space token with category code $10$ (blank space).
If the \meta{string} is empty, then nothing is returned.
\end{function}

\begin{function}{\StrVarHead}
\begin{syntax}
\cs{StrVarHead} \meta{tl var}
\end{syntax}
Converts the \meta{tl var} into a \meta{string}.
The first character in the \meta{string} is then returned,
with category code \enquote{other}. If the first character is a space,
it returns a space token with category code $10$ (blank space).
If the \meta{string} is empty, then nothing is returned.
\end{function}

\begin{function}{\StrTail}
\begin{syntax}
\cs{StrTail} \Arg{token list}
\end{syntax}
Converts the \meta{token list} to a \meta{string}, removes the first
character, and returns the remaining characters (if any)
with category codes $12$ and $10$ (for spaces).
If the first character is a space, it only trims that space.
If the \meta{token list} is empty,
then nothing is left on the input stream.
\end{function}

\begin{function}{\StrVarTail}
\begin{syntax}
\cs{StrVarTail} \meta{tl var}
\end{syntax}
Converts the \meta{tl var} to a \meta{string}, removes the first
character, and returns the remaining characters (if any)
with category codes $12$ and $10$ (for spaces).
If the first character is a space, it only trims that space.
If the \meta{token list} is empty,
then nothing is left on the input stream.
\end{function}

\begin{function}{\StrItem}
\begin{syntax}
\cs{StrItem} \Arg{token list} \Arg{integer expression}
\end{syntax}
Converts the \meta{token list} to a \meta{string},
and returns the character in position \meta{integer expression} of
the \meta{string}, starting at $1$ for the first (left-most)
character. All characters including spaces are taken into account.
If the \meta{integer expression} is negative,
characters are counted from the end of the \meta{string}. Hence,
$-1$ is the right-most character, \emph{etc.}
\end{function}

\begin{function}{\StrVarItem}
\begin{syntax}
\cs{StrVarItem} \meta{tl var} \Arg{integer expression}
\end{syntax}
Converts the \meta{tl var} to a \meta{string},
and returns the character in position \meta{integer expression} of
the \meta{string}, starting at $1$ for the first (left-most)
character. All characters including spaces are taken into account.
If the \meta{integer expression} is negative,
characters are counted from the end of the \meta{string}. Hence,
$-1$ is the right-most character, \emph{etc.}
\end{function}

\section{Mapping over Strings}

All mappings are done at the current group level, \emph{i.e.} any
local assignments made by the \meta{function} or \meta{code} discussed
below remain in effect after the loop.

%\begin{function}{\StrMapFunction,\StrVarMapFunction}
%\begin{syntax}
%\cs{StrMapFunction} \Arg{token list} \meta{function}
%\cs{StrVarMapFunction} \meta{str var} \meta{function}
%\end{syntax}
%Converts the \meta{token list} to a \meta{string} then
%applies \meta{function} to every \meta{character} in the
%\meta{string} including spaces.
%\end{function}

\begin{function}{\StrMapInline,\StrVarMapInline}
\begin{syntax}
\cs{StrMapInline} \Arg{token list} \Arg{inline function}
\cs{StrVarMapInline} \meta{str var} \Arg{inline function}
\end{syntax}
Converts the \meta{token list} to a \meta{string} then
applies the \meta{inline function} to every \meta{character} in the
\meta{str var} including spaces.
The \meta{inline function} should consist of code which
receives the \meta{character} as \verb|#1|.
\end{function}

%\begin{function}{\StrMapTokens, \StrVarMapTokens}
%\begin{syntax}
%\cs{StrMapTokens} \Arg{token list} \Arg{code}
%\cs{StrVarMapTokens} \meta{str var} \Arg{code}
%\end{syntax}
%Converts the \meta{token list} to a \meta{string} then applies
%\meta{code} to every \meta{character} in the \meta{string} including spaces.
%The \meta{code} receives each character as a trailing brace group.
%This is equivalent to \cs{StrMapFunction} if the
%\meta{code} consists of a single function.
%\end{function}

\begin{function}{\StrMapVariable,\StrMapVariable}
\begin{syntax}
\cs{StrMapVariable} \Arg{token list} \meta{variable} \Arg{code}
\cs{StrVarMapVariable} \meta{str var} \meta{variable} \Arg{code}
\end{syntax}
Converts the \meta{token list} to a \meta{string} then stores each
\meta{character} in the \meta{string} (including spaces) in turn in
the (string or token list) \meta{variable} and applies the
\meta{code}.  The \meta{code} will usually make use of the
\meta{variable}, but this is not enforced.  The assignments to the
\meta{variable} are local.  Its value after the loop is the last
\meta{character} in the \meta{string}, or its original value if the
\meta{string} is empty.
\end{function}

%\begin{function}{\StrMapBreak}
%\begin{syntax}
%\cs{StrMapBreak}
%\end{syntax}
%Used to terminate a string map function before all
%characters in the \meta{string} have been processed. This
%normally takes place within a conditional statement, for example
%\begin{verbatim}
%\str_map_inline:Nn \l_my_str
%{
%\str_if_eq:nnT { #1 } { bingo } { \str_map_break: }
%Do something useful
%}
%\end{verbatim}
%See also \cs{StrMapBreakDo}.
%Use outside of a string map scenario leads to low
%level \TeX{} errors.
%\begin{texnote}
%When the mapping is broken, additional tokens may be inserted
%before continuing with the
%code that follows the loop.
%This depends on the design of the mapping function.
%\end{texnote}
%\end{function}
%
%\begin{function}{\StrMapBreakDo}
%\begin{syntax}
%\cs{StrMapBreakDo} \Arg{code}
%\end{syntax}
%Used to terminate a string map function before all
%characters in the \meta{string} have been processed, inserting
%the \meta{code} after the mapping has ended. This
%normally takes place within a conditional statement, for example
%\begin{verbatim}
%\str_map_inline:Nn \l_my_str
%{
%\str_if_eq:nnT { #1 } { bingo }
%{ \str_map_break:n { <code> } }
%Do something useful
%}
%\end{verbatim}
%Use outside of a string map scenario leads to low
%level \TeX{} errors.
%\begin{texnote}
%When the mapping is broken, additional tokens may be inserted
%before the \meta{code} is
%inserted into the input stream.
%This depends on the design of the mapping function.
%\end{texnote}
%\end{function}

\section{String Conditionals}

\begin{function}{\StrIfExist,\StrIfExistTF}
\begin{syntax}
\cs{StrIfExist} \meta{str var}
\cs{StrIfExistTF} \meta{str var} \Arg{true code} \Arg{false code}
\end{syntax}
Tests whether the \meta{str var} is currently defined.  This does not
check that the \meta{str var} really is a string.
\end{function}

\begin{function}{\StrVarIfEmpty,\StrVarIfEmptyTF}
\begin{syntax}
\cs{StrVarIfEmpty} \meta{str var}
\cs{StrVarIfEmptyTF} \meta{str var} \Arg{true code} \Arg{false code}
\end{syntax}
Tests if the \meta{string variable} is entirely empty
(\emph{i.e.} contains no characters at all). For example
\begin{demohigh}
\StrSet \lTmpaStr {abc}
\StrVarIfEmptyTF \lTmpaStr {\Result{Empty}} {\Result{NonEmpty}}
\StrClear \lTmpaStr
\StrVarIfEmptyTF \lTmpaStr {\Result{Empty}} {\Result{NonEmpty}}
\end{demohigh}
\end{function}

\begin{function}{\StrIfEq,\StrIfEqTF}
\begin{syntax}
\cs{StrIfEq} \Arg{tl_1} \Arg{tl_2}
\cs{StrIfEqTF} \Arg{tl_1} \Arg{tl_2} \Arg{true code} \Arg{false code}
\end{syntax}
Compares the two \meta{token lists} on a character by character
basis (namely after converting them to strings),
and is \texttt{true} if the two \meta{strings} contain the same
characters in the same order.
%Thus for example
%\begin{codehigh}
%\StrIfEq{abc}{\TlToStr{abc}}
%\end{codehigh}
%is logically \texttt{true}.
See \cs{TlIfEq} to compare
tokens (including their category codes) rather than characters.
For example
\begin{demohigh}
\StrIfEqTF {abc} {abc} {\Result{Yes}} {\Result{No}}
\StrIfEqTF {abc} {xyz} {\Result{Yes}} {\Result{No}}
\end{demohigh}
%\begin{demohigh}
%\StrSet\lTmpaStr{abc}
%\StrSet\lTmpbStr{abc}
%\StrSet\lTmpcStr{xyz}
%\StrIfEqTF{\lTmpaStr}{\lTmpbStr}{\Result{Yes}}{\Result{No}}
%\StrIfEqTF{\lTmpaStr}{\lTmpcStr}{\Result{Yes}}{\Result{No}}
%\StrIfEqTF{\StrUse\lTmpaStr}{\StrUse\lTmpbStr}{\Result{Yes}}{\Result{No}}
%\StrIfEqTF{\StrUse\lTmpaStr}{\StrUse\lTmpcStr}{\Result{Yes}}{\Result{No}}
%\end{demohigh}
\end{function}

\begin{function}{\StrVarIfEq,\StrVarIfEqTF}
\begin{syntax}
\cs{StrVarIfEq} \meta{str var_1} \meta{str var_2}
\cs{StrVarIfEqTF} \meta{str var_1} \meta{str var_2} \Arg{true code} \Arg{false code}
\end{syntax}
Compares the content of two \meta{str variables} and
is logically \texttt{true} if the two contain the same characters
in the same order.  See \cs{TlVarIfEq} to compare tokens
(including their category codes) rather than characters.
\begin{demohigh}
\StrSet \lTmpaStr {abc}
\StrSet \lTmpbStr {abc}
\StrSet \lTmpcStr {xyz}
\StrVarIfEqTF \lTmpaStr \lTmpbStr {\Result{Yes}} {\Result{No}}
\StrVarIfEqTF \lTmpaStr \lTmpcStr {\Result{Yes}} {\Result{No}}
\end{demohigh}
\end{function}

\begin{function}{\StrIfIn,\StrIfInTF}
\begin{syntax}
\cs{StrIfInTF} \Arg{tl_1} \Arg{tl_2}
\cs{StrIfInTF} \Arg{tl_1} \Arg{tl_2} \Arg{true code} \Arg{false code}
\end{syntax}
Converts both \meta{token lists} to \meta{strings} and
tests whether \meta{string_2} is found inside \meta{string_1}.
\end{function}

\begin{function}{\StrVarIfIn,\StrVarIfInTF}
\begin{syntax}
\cs{StrVarIfInTF} \meta{str var} \Arg{token list}
\cs{StrVarIfInTF} \meta{str var} \Arg{token list} \Arg{true code} \Arg{false code}
\end{syntax}
Converts the \meta{token list} to a \meta{string} and
tests if that \meta{string} is found in the content of the
\meta{str var}.
\end{function}

\begin{function}{\StrCompare,\StrCompareTF}
\begin{syntax}
\cs{StrCompare} \Arg{tl_1} \meta{relation} \Arg{tl_2}
\cs{StrCompareTF} \Arg{tl_1} \meta{relation} \Arg{tl_2} \Arg{true code} \Arg{false code}
\end{syntax}
Compares the two \meta{token lists} on a character by character
basis (namely after converting them to strings) in a lexicographic
order according to the character codes of the characters.  The
\meta{relation} can be \verb|<|, \verb|=|, or \verb|>| and the test is
\texttt{true} under the following conditions:
\begin{itemize}[nosep]
\item for \verb|<|, if the first string is earlier than the second in lexicographic order;
\item for \verb|=|, if the two strings have exactly the same characters;
\item for \verb|>|, if the first string is later than the second in lexicographic order.
\end{itemize}
For example:
\begin{demohigh}
\StrCompareTF {ab} < {abc} {\Result{Yes}} {\Result{No}}
\StrCompareTF {ab} < {aa} {\Result{Yes}} {\Result{No}}
\end{demohigh}
%\begin{texnote}
%This is a wrapper around the \TeX{} primitive
%\cs{(pdf)strcmp}.  It is meant for programming
%and not for sorting textual contents, as it simply considers
%character codes and not more elaborate considerations of grapheme
%clusters, locale, etc.
%\end{texnote}
\par
Due to naming conflict, you need to use \cs{StrIfCompare}/\cs{StrIfCompareTF} as a replacement
if you want to use \verb!functional! package together with \verb!xstring! package.
\end{function}

\section{String Case Functions}

\begin{function}{\StrCase}
\begin{syntax}
\cs{StrCase} \Arg{test string}
~ ~ \verb|{|
~ ~ ~ ~ \Arg{string case_1} \Arg{code case_1}
~ ~ ~ ~ \Arg{string case_2} \Arg{code case_2}
~ ~ ~ ~ $\cdots$
~ ~ ~ ~ \Arg{string case_n} \Arg{code case_n}
~ ~ \verb|}|
\end{syntax}
Compares the \meta{test string} in turn with each
of the \meta{string cases} (all token lists are converted to strings).
If the two are equal (as described for
\cs{StrIfEq}) then the associated \meta{code} is left in the
input stream and other cases are discarded.
\end{function}

\begin{function}{\StrCaseT}
\begin{syntax}
\cs{StrCaseT} \Arg{test string}
~ ~ \verb|{|
~ ~ ~ ~ \Arg{string case_1} \Arg{code case_1}
~ ~ ~ ~ \Arg{string case_2} \Arg{code case_2}
~ ~ ~ ~ $\cdots$
~ ~ ~ ~ \Arg{string case_n} \Arg{code case_n}
~ ~ \verb|}|
~ ~ \Arg{true code}
\end{syntax}
Compares the \meta{test string} in turn with each
of the \meta{string cases} (all token lists are converted to strings).
If the two are equal (as described for
\cs{StrIfEq}) then the associated \meta{code} is left in the
input stream and other cases are discarded. If any of the
cases are matched, the \meta{true code} is also inserted into the
input stream (after the code for the appropriate case).
\end{function}

\begin{function}{\StrCaseF}
\begin{syntax}
\cs{StrCaseF} \Arg{test string}
~ ~ \verb|{|
~ ~ ~ ~ \Arg{string case_1} \Arg{code case_1}
~ ~ ~ ~ \Arg{string case_2} \Arg{code case_2}
~ ~ ~ ~ $\cdots$
~ ~ ~ ~ \Arg{string case_n} \Arg{code case_n}
~ ~ \verb|}|
~ ~ \Arg{false code}
\end{syntax}
Compares the \meta{test string} in turn with each
of the \meta{string cases} (all token lists are converted to strings).
If the two are equal (as described for
\cs{StrIfEq}) then the associated \meta{code} is left in the
input stream and other cases are discarded. If none
match then the \meta{false code} is inserted.
\end{function}

\begin{function}{\StrCaseTF}
\begin{syntax}
\cs{StrCaseTF} \Arg{test string}
~ ~ \verb|{|
~ ~ ~ ~ \Arg{string case_1} \Arg{code case_1}
~ ~ ~ ~ \Arg{string case_2} \Arg{code case_2}
~ ~ ~ ~ $\cdots$
~ ~ ~ ~ \Arg{string case_n} \Arg{code case_n}
~ ~ \verb|}|
~ ~ \Arg{true code}
~ ~ \Arg{false code}
\end{syntax}
Compares the \meta{test string} in turn with each
of the \meta{string cases} (all token lists are converted to strings).
If the two are equal (as described for
\cs{StrIfEq}) then the associated \meta{code} is left in the
input stream and other cases are discarded. If any of the
cases are matched, the \meta{true code} is also inserted into the
input stream (after the code for the appropriate case), while if none
match then the \meta{false code} is inserted.
\end{function}

\end{document}
